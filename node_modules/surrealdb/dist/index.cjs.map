{
  "version": 3,
  "sources": ["../src/index.ts", "../src/util/emitter.ts", "../src/cbor/gap.ts", "../src/cbor/index.ts", "../src/cbor/constants.ts", "../src/cbor/encoded.ts", "../src/errors.ts", "../src/cbor/error.ts", "../src/cbor/writer.ts", "../src/cbor/partial.ts", "../src/cbor/tagged.ts", "../src/cbor/encoder.ts", "../src/cbor/reader.ts", "../src/cbor/util.ts", "../src/cbor/decoder.ts", "../src/data/types/datetime.ts", "../src/data/value.ts", "../src/data/types/decimal.ts", "../src/data/types/duration.ts", "../src/data/types/future.ts", "../src/data/types/geometry.ts", "../src/util/equals.ts", "../src/util/escape.ts", "../src/data/types/uuid.ts", "../src/data/types/recordid.ts", "../src/data/types/table.ts", "../src/util/to-surrealql-string.ts", "../src/data/types/range.ts", "../src/data/cbor.ts", "../src/util/prepared-query.ts", "../src/util/tagged-template.ts", "../src/types.ts", "../src/util/jsonify.ts", "../src/util/version-check.ts", "../src/util/get-incremental-id.ts", "../src/util/string-prefixes.ts", "../src/engines/abstract.ts", "../src/util/process-auth-vars.ts", "../src/auth.ts", "../src/engines/abstract-remote.ts", "../src/engines/http.ts", "../src/engines/ws.ts", "../src/util/completable.ts", "../src/util/rand.ts", "../src/util/reconnect.ts", "../src/surreal.ts"],
  "sourcesContent": ["export { Emitter, type Listener, type UnknownEvents } from \"./util/emitter.ts\";\nexport { surql, surrealql } from \"./util/tagged-template.ts\";\nexport { PreparedQuery } from \"./util/prepared-query.ts\";\nexport * as cbor from \"./cbor\";\nexport * from \"./cbor/gap\";\nexport * from \"./cbor/error\";\nexport * from \"./data\";\nexport * from \"./errors.ts\";\nexport * from \"./types.ts\";\nexport * from \"./util/equals.ts\";\nexport * from \"./util/jsonify.ts\";\nexport * from \"./util/version-check.ts\";\nexport * from \"./util/get-incremental-id.ts\";\nexport * from \"./util/string-prefixes.ts\";\nexport * from \"./util/to-surrealql-string.ts\";\nexport * from \"./util/escape.ts\";\nexport {\n\tConnectionStatus,\n\tAbstractEngine,\n\ttype Engine,\n\ttype Engines,\n\ttype EngineEvents,\n} from \"./engines/abstract.ts\";\nexport { Surreal, Surreal as default } from \"./surreal.ts\";\nexport { EngineAuth, AuthController } from \"./auth.ts\";\n", "export type Listener<Args extends unknown[] = unknown[]> = (\n\t...args: Args\n) => unknown;\nexport type UnknownEvents = Record<string, unknown[]>;\n\n/**\n * A class used to subscribe to and emit events\n */\nexport class Emitter<Events extends UnknownEvents = UnknownEvents> {\n\tprivate collectable: Partial<{\n\t\t[K in keyof Events]: Events[K][];\n\t}> = {};\n\n\tprivate listeners: Partial<{\n\t\t[K in keyof Events]: Listener<Events[K]>[];\n\t}> = {};\n\n\tprivate readonly interceptors: Partial<{\n\t\t[K in keyof Events]: (...args: Events[K]) => Promise<Events[K]>;\n\t}>;\n\n\tconstructor({\n\t\tinterceptors,\n\t}: {\n\t\tinterceptors?: Partial<{\n\t\t\t[K in keyof Events]: (...args: Events[K]) => Promise<Events[K]>;\n\t\t}>;\n\t} = {}) {\n\t\tthis.interceptors = interceptors ?? {};\n\t}\n\n\tsubscribe<Event extends keyof Events>(\n\t\tevent: Event,\n\t\tlistener: Listener<Events[Event]>,\n\t\thistoric = false,\n\t): void {\n\t\tif (!this.listeners[event]) {\n\t\t\tthis.listeners[event] = [];\n\t\t}\n\n\t\tif (!this.isSubscribed(event, listener)) {\n\t\t\tthis.listeners[event]?.push(listener);\n\n\t\t\tif (historic && this.collectable[event]) {\n\t\t\t\tconst buffer = this.collectable[event];\n\t\t\t\tdelete this.collectable[event];\n\t\t\t\tfor (const args of buffer) {\n\t\t\t\t\tlistener(...args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync subscribeOnce<Event extends keyof Events>(\n\t\tevent: Event,\n\t\thistoric = false,\n\t): Promise<Events[Event]> {\n\t\tif (historic && this.collectable[event]) {\n\t\t\tconst args = this.collectable[event]?.shift();\n\t\t\tif (this.collectable[event]?.length === 0) {\n\t\t\t\tdelete this.collectable[event];\n\t\t\t}\n\n\t\t\tif (args) return args;\n\t\t}\n\n\t\treturn new Promise<Events[Event]>((resolve) => {\n\t\t\tlet resolved = false;\n\t\t\tconst listener = (...args: Events[Event]) => {\n\t\t\t\tif (!resolved) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tthis.unSubscribe(event, listener);\n\t\t\t\t\tresolve(args);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.subscribe(event, listener, false);\n\t\t});\n\t}\n\n\tunSubscribe<Event extends keyof Events>(\n\t\tevent: Event,\n\t\tlistener: Listener<Events[Event]>,\n\t): void {\n\t\tif (this.listeners[event]) {\n\t\t\tconst index = this.listeners[event]?.findIndex((v) => v === listener);\n\t\t\tif (index >= 0) {\n\t\t\t\tthis.listeners[event]?.splice(index, 1);\n\t\t\t\tif (this.listeners[event]?.length === 0) {\n\t\t\t\t\tdelete this.listeners[event];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tisSubscribed<Event extends keyof Events>(\n\t\tevent: Event,\n\t\tlistener: Listener<Events[Event]>,\n\t): boolean {\n\t\treturn !!this.listeners[event]?.includes(listener);\n\t}\n\n\tasync emit<Event extends keyof Events>(\n\t\tevent: Event,\n\t\targs: Events[Event],\n\t\tcollectable = false,\n\t): Promise<void> {\n\t\tconst interceptor = this.interceptors[event];\n\t\tconst computedArgs = interceptor ? await interceptor(...args) : args;\n\n\t\tif (\n\t\t\t(collectable && !this.listeners[event]) ||\n\t\t\tthis.listeners[event]?.length === 0\n\t\t) {\n\t\t\tif (!this.collectable[event]) {\n\t\t\t\tthis.collectable[event] = [];\n\t\t\t}\n\n\t\t\tthis.collectable[event]?.push(args);\n\t\t}\n\n\t\tfor (const listener of this.listeners[event] ?? []) {\n\t\t\tlistener(...computedArgs);\n\t\t}\n\t}\n\n\treset({\n\t\tcollectable,\n\t\tlisteners,\n\t}: {\n\t\tcollectable?: boolean | keyof Events | (keyof Events)[];\n\t\tlisteners?: boolean | keyof Events | (keyof Events)[];\n\t}): void {\n\t\tif (Array.isArray(collectable)) {\n\t\t\tfor (const k of collectable) {\n\t\t\t\tdelete this.collectable[k];\n\t\t\t}\n\t\t} else if (typeof collectable === \"string\") {\n\t\t\tdelete this.collectable[collectable];\n\t\t} else if (collectable !== false) {\n\t\t\tthis.collectable = {};\n\t\t}\n\n\t\tif (Array.isArray(listeners)) {\n\t\t\tfor (const k of listeners) {\n\t\t\t\tdelete this.listeners[k];\n\t\t\t}\n\t\t} else if (typeof listeners === \"string\") {\n\t\t\tdelete this.listeners[listeners];\n\t\t} else if (listeners !== false) {\n\t\t\tthis.listeners = {};\n\t\t}\n\t}\n\n\tscanListeners(filter?: (k: keyof Events) => boolean): (keyof Events)[] {\n\t\tlet listeners = Object.keys(this.listeners) as (keyof Events)[];\n\t\tif (filter) listeners = listeners.filter(filter);\n\t\treturn listeners;\n\t}\n}\n", "// Why is the default value being stored in an array? undefined, null, false, etc... are all valid defaults,\n// and specifying a field on a class as optional will make it undefined by default.\n\nexport type Fill<T = unknown> = [Gap<T>, T];\nexport class Gap<T = unknown> {\n\treadonly args: [T?] = [];\n\tconstructor(...args: [T?]) {\n\t\tthis.args = args;\n\t}\n\n\tfill(value: T): Fill<T> {\n\t\treturn [this, value];\n\t}\n\n\thasDefault(): boolean {\n\t\treturn this.args.length === 1;\n\t}\n\n\tget default(): T | undefined {\n\t\treturn this.args[0];\n\t}\n}\n", "export * from \"./constants\";\nexport * from \"./encoder\";\nexport * from \"./decoder\";\nexport * from \"./util\";\nexport * from \"./reader\";\nexport * from \"./writer\";\nexport * from \"./tagged\";\nexport * from \"./error\";\nexport * from \"./gap\";\nexport * from \"./partial\";\nexport * from \"./encoded\";\n", "export type Replacer = (v: unknown) => unknown;\nexport type Major = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\nexport const POW_2_53: number = 2 ** 53;\nexport const POW_2_64: bigint = BigInt(2 ** 64);\n", "export class Encoded {\n\tconstructor(readonly encoded: ArrayBuffer) {}\n}\n", "export class SurrealDbError extends Error {}\n\nexport class NoActiveSocket extends SurrealDbError {\n\tname = \"NoActiveSocket\";\n\tmessage =\n\t\t\"No socket is currently connected to a SurrealDB instance. Please call the .connect() method first!\";\n}\n\nexport class NoConnectionDetails extends SurrealDbError {\n\tname = \"NoConnectionDetails\";\n\tmessage =\n\t\t\"No connection details for the HTTP api have been provided. Please call the .connect() method first!\";\n}\n\nexport class UnexpectedResponse extends SurrealDbError {\n\tname = \"UnexpectedResponse\";\n\tmessage =\n\t\t\"The returned response from the SurrealDB instance is in an unexpected format. Unable to process response!\";\n}\n\nexport class InvalidURLProvided extends SurrealDbError {\n\tname = \"InvalidURLProvided\";\n\tmessage =\n\t\t\"The provided string is either not a URL or is a URL but with an invalid protocol!\";\n}\n\nexport class NoURLProvided extends SurrealDbError {\n\tname = \"NoURLProvided\";\n\tmessage =\n\t\t\"Tried to establish a connection while no connection URL was provided\";\n}\n\nexport class EngineDisconnected extends SurrealDbError {\n\tname = \"EngineDisconnected\";\n\tmessage = \"The engine reported the connection to SurrealDB has dropped\";\n}\n\nexport class ReconnectFailed extends SurrealDbError {\n\tname = \"ReconnectFailed\";\n\tmessage = \"The engine failed to reconnect to SurrealDB\";\n}\n\nexport class ReconnectIterationError extends SurrealDbError {\n\tname = \"ReconnectIterationError\";\n\tmessage = \"The reconnect iterator failed to iterate\";\n}\n\nexport class UnexpectedServerResponse extends SurrealDbError {\n\tname = \"UnexpectedServerResponse\";\n\n\tconstructor(public readonly response: unknown) {\n\t\tsuper();\n\t\tthis.message = `${response}`;\n\t}\n}\n\nexport class UnexpectedConnectionError extends SurrealDbError {\n\tname = \"UnexpectedConnectionError\";\n\n\tconstructor(public readonly error: unknown) {\n\t\tsuper();\n\t\tthis.message = `${error}`;\n\t}\n}\n\nexport class UnsupportedEngine extends SurrealDbError {\n\tname = \"UnsupportedEngine\";\n\tmessage =\n\t\t\"The engine you are trying to connect to is not supported or configured.\";\n\n\tconstructor(public readonly engine: string) {\n\t\tsuper();\n\t}\n}\n\nexport class FeatureUnavailableForEngine extends SurrealDbError {\n\tname = \"FeatureUnavailableForEngine\";\n\tmessage =\n\t\t\"The feature you are trying to use is not available on this engine.\";\n}\n\nexport class ConnectionUnavailable extends SurrealDbError {\n\tname = \"ConnectionUnavailable\";\n\tmessage = \"There is no connection available at this moment.\";\n}\n\nexport class MissingNamespaceDatabase extends SurrealDbError {\n\tname = \"MissingNamespaceDatabase\";\n\tmessage = \"There is no namespace and/or database selected.\";\n}\n\nexport class HttpConnectionError extends SurrealDbError {\n\tname = \"HttpConnectionError\";\n\n\tconstructor(\n\t\tpublic readonly message: string,\n\t\tpublic readonly status: number,\n\t\tpublic readonly statusText: string,\n\t\tpublic readonly buffer: ArrayBuffer,\n\t) {\n\t\tsuper();\n\t}\n}\n\nexport class ResponseError extends SurrealDbError {\n\tname = \"ResponseError\";\n\n\tconstructor(public readonly message: string) {\n\t\tsuper();\n\t}\n}\n\nexport class NoNamespaceSpecified extends SurrealDbError {\n\tname = \"NoNamespaceSpecified\";\n\tmessage = \"Please specify a namespace to use.\";\n}\n\nexport class NoDatabaseSpecified extends SurrealDbError {\n\tname = \"NoDatabaseSpecified\";\n\tmessage = \"Please specify a database to use.\";\n}\n\nexport class NoTokenReturned extends SurrealDbError {\n\tname = \"NoTokenReturned\";\n\tmessage = \"Did not receive an authentication token.\";\n}\n\nexport class UnsupportedVersion extends SurrealDbError {\n\tname = \"UnsupportedVersion\";\n\tversion: string;\n\tsupportedRange: string;\n\n\tconstructor(version: string, supportedRange: string) {\n\t\tsuper();\n\t\tthis.version = version;\n\t\tthis.supportedRange = supportedRange;\n\t\tthis.message = `The version \"${version}\" reported by the engine is not supported by this library, expected a version that satisfies \"${supportedRange}\".`;\n\t}\n}\n\nexport class VersionRetrievalFailure extends SurrealDbError {\n\tname = \"VersionRetrievalFailure\";\n\tmessage =\n\t\t\"Failed to retrieve remote version. If the server is behind a proxy, make sure it's configured correctly.\";\n\n\tconstructor(readonly error?: Error | undefined) {\n\t\tsuper();\n\t}\n}\n", "import { SurrealDbError } from \"../errors\";\n\nexport abstract class CborError extends SurrealDbError {\n\tabstract readonly name: string;\n\treadonly message: string;\n\n\tconstructor(message: string) {\n\t\tsuper();\n\t\tthis.message = message;\n\t}\n}\n\nexport class CborNumberError extends CborError {\n\tname = \"CborNumberError\";\n}\n\nexport class CborRangeError extends CborError {\n\tname = \"CborRangeError\";\n}\n\nexport class CborInvalidMajorError extends CborError {\n\tname = \"CborInvalidMajorError\";\n}\n\nexport class CborBreak extends CborError {\n\tname = \"CborBreak\";\n\tconstructor() {\n\t\tsuper(\"Came across a break which was not intercepted by the decoder\");\n\t}\n}\n\nexport class CborPartialDisabled extends CborError {\n\tname = \"CborPartialDisabled\";\n\tconstructor() {\n\t\tsuper(\n\t\t\t\"Tried to insert a Gap into a CBOR value, while partial mode is not enabled\",\n\t\t);\n\t}\n}\n\nexport class CborFillMissing extends CborError {\n\tname = \"CborFillMissing\";\n\tconstructor() {\n\t\tsuper(\"Fill for a gap is missing, and gap has no default\");\n\t}\n}\n", "import type { Major, Replacer } from \"./constants\";\nimport type { Gap } from \"./gap\";\nimport { PartiallyEncoded } from \"./partial\";\n\nexport class Writer {\n\tprivate _chunks: [ArrayBuffer, Gap][] = [];\n\tprivate _pos = 0;\n\tprivate _buf: ArrayBuffer;\n\tprivate _view: DataView;\n\tprivate _byte: Uint8Array;\n\n\tconstructor(readonly byteLength = 256) {\n\t\tthis._buf = new ArrayBuffer(this.byteLength);\n\t\tthis._view = new DataView(this._buf);\n\t\tthis._byte = new Uint8Array(this._buf);\n\t}\n\n\tchunk(gap: Gap): void {\n\t\tthis._chunks.push([this._buf.slice(0, this._pos), gap]);\n\t\tthis._buf = new ArrayBuffer(this.byteLength);\n\t\tthis._view = new DataView(this._buf);\n\t\tthis._byte = new Uint8Array(this._buf);\n\t\tthis._pos = 0;\n\t}\n\n\tget chunks(): [ArrayBuffer, Gap][] {\n\t\treturn this._chunks;\n\t}\n\n\tget buffer(): ArrayBuffer {\n\t\treturn this._buf.slice(0, this._pos);\n\t}\n\n\tprivate claim(length: number) {\n\t\tconst pos = this._pos;\n\t\tthis._pos += length;\n\t\tif (this._pos <= this._buf.byteLength) return pos;\n\n\t\tlet newLen = this._buf.byteLength << 1;\n\t\twhile (newLen < this._pos) newLen <<= 1;\n\t\tif (newLen > this._buf.byteLength) {\n\t\t\tconst oldb = this._byte;\n\t\t\tthis._buf = new ArrayBuffer(newLen);\n\t\t\tthis._view = new DataView(this._buf);\n\t\t\tthis._byte = new Uint8Array(this._buf);\n\t\t\tthis._byte.set(oldb);\n\t\t}\n\t\treturn pos;\n\t}\n\n\twriteUint8(value: number): void {\n\t\tconst pos = this.claim(1);\n\t\tthis._view.setUint8(pos, value);\n\t}\n\n\twriteUint16(value: number): void {\n\t\tconst pos = this.claim(2);\n\t\tthis._view.setUint16(pos, value);\n\t}\n\n\twriteUint32(value: number): void {\n\t\tconst pos = this.claim(4);\n\t\tthis._view.setUint32(pos, value);\n\t}\n\n\twriteUint64(value: bigint): void {\n\t\tconst pos = this.claim(8);\n\t\tthis._view.setBigUint64(pos, value);\n\t}\n\n\twriteUint8Array(data: Uint8Array): void {\n\t\tif (data.byteLength === 0) return;\n\t\tconst pos = this.claim(data.byteLength);\n\t\tthis._byte.set(data, pos);\n\t}\n\n\twriteArrayBuffer(data: ArrayBuffer): void {\n\t\tif (data.byteLength === 0) return;\n\t\tthis.writeUint8Array(new Uint8Array(data));\n\t}\n\n\twritePartiallyEncoded(data: PartiallyEncoded): void {\n\t\tfor (const [buf, gap] of data.chunks) {\n\t\t\tthis.writeArrayBuffer(buf);\n\t\t\tthis.chunk(gap);\n\t\t}\n\n\t\tthis.writeArrayBuffer(data.end);\n\t}\n\n\twriteFloat32(value: number): void {\n\t\tconst pos = this.claim(4);\n\t\tthis._view.setFloat32(pos, value);\n\t}\n\n\twriteFloat64(value: number): void {\n\t\tconst pos = this.claim(8);\n\t\tthis._view.setFloat64(pos, value);\n\t}\n\n\twriteMajor(type: Major, length: number | bigint): void {\n\t\tconst base = type << 5;\n\t\tif (length < 24) {\n\t\t\tthis.writeUint8(base + Number(length));\n\t\t} else if (length < 0x100) {\n\t\t\tthis.writeUint8(base + 24);\n\t\t\tthis.writeUint8(Number(length));\n\t\t} else if (length < 0x10000) {\n\t\t\tthis.writeUint8(base + 25);\n\t\t\tthis.writeUint16(Number(length));\n\t\t} else if (length < 0x100000000) {\n\t\t\tthis.writeUint8(base + 26);\n\t\t\tthis.writeUint32(Number(length));\n\t\t} else {\n\t\t\tthis.writeUint8(base + 27);\n\t\t\tthis.writeUint64(BigInt(length));\n\t\t}\n\t}\n\n\toutput<Partial extends boolean = false>(\n\t\tpartial: Partial,\n\t\treplacer?: Replacer,\n\t): Partial extends true ? PartiallyEncoded : ArrayBuffer {\n\t\tif (partial) {\n\t\t\treturn new PartiallyEncoded(\n\t\t\t\tthis._chunks,\n\t\t\t\tthis.buffer,\n\t\t\t\treplacer,\n\t\t\t) as Partial extends true ? PartiallyEncoded : ArrayBuffer;\n\t\t}\n\n\t\treturn this.buffer as Partial extends true ? PartiallyEncoded : ArrayBuffer;\n\t}\n}\n", "import type { Replacer } from \"./constants\";\nimport { type EncoderOptions, encode } from \"./encoder\";\nimport { CborFillMissing } from \"./error\";\nimport type { Fill, Gap } from \"./gap\";\nimport { Writer } from \"./writer\";\n\nexport class PartiallyEncoded {\n\tconstructor(\n\t\treadonly chunks: [ArrayBuffer, Gap][],\n\t\treadonly end: ArrayBuffer,\n\t\treadonly replacer: Replacer | undefined,\n\t) {}\n\n\tbuild<Partial extends boolean = false>(\n\t\tfills: Fill[],\n\t\tpartial?: Partial,\n\t): Partial extends true ? PartiallyEncoded : ArrayBuffer {\n\t\tconst writer = new Writer();\n\t\tconst map = new Map(fills);\n\n\t\tfor (const [buffer, gap] of this.chunks) {\n\t\t\tconst hasValue = map.has(gap) || gap.hasDefault();\n\t\t\tif (!partial && !hasValue) throw new CborFillMissing();\n\t\t\twriter.writeArrayBuffer(buffer);\n\n\t\t\tif (hasValue) {\n\t\t\t\tconst data = map.get(gap) ?? gap.default;\n\t\t\t\tencode(data, {\n\t\t\t\t\twriter,\n\t\t\t\t\treplacer: this.replacer,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\twriter.chunk(gap);\n\t\t\t}\n\t\t}\n\n\t\twriter.writeArrayBuffer(this.end);\n\t\treturn writer.output<Partial>(!!partial as Partial, this.replacer);\n\t}\n}\n\nexport function partiallyEncodeObject(\n\tobject: Record<string, unknown>,\n\toptions?: EncoderOptions<true>,\n): Record<string, PartiallyEncoded> {\n\treturn Object.fromEntries(\n\t\tObject.entries(object).map(([k, v]) => [\n\t\t\tk,\n\t\t\tencode(v, { ...options, partial: true }),\n\t\t]),\n\t);\n}\n", "export class Tagged<T = unknown> {\n\tconstructor(\n\t\treadonly tag: number | bigint,\n\t\treadonly value: T,\n\t) {}\n}\n", "import { POW_2_53, POW_2_64, type Replacer } from \"./constants\";\nimport { Encoded } from \"./encoded\";\nimport { CborNumberError, CborPartialDisabled } from \"./error\";\nimport { type Fill, Gap } from \"./gap\";\nimport { PartiallyEncoded } from \"./partial\";\nimport { Tagged } from \"./tagged\";\nimport { Writer } from \"./writer\";\n\nlet textEncoder: TextEncoder;\n\nexport interface EncoderOptions<Partial extends boolean> {\n\treplacer?: Replacer;\n\twriter?: Writer;\n\tpartial?: Partial;\n\tfills?: Fill[];\n}\n\nexport function encode<Partial extends boolean = false>(\n\tinput: unknown,\n\toptions: EncoderOptions<Partial> = {},\n): Partial extends true ? PartiallyEncoded : ArrayBuffer {\n\tconst w = options.writer ?? new Writer();\n\tconst fillsMap = new Map(options.fills ?? []);\n\n\tfunction inner(input: unknown) {\n\t\tconst value = options.replacer ? options.replacer(input) : input;\n\n\t\tif (value === undefined) return w.writeUint8(0xf7);\n\t\tif (value === null) return w.writeUint8(0xf6);\n\t\tif (value === true) return w.writeUint8(0xf5);\n\t\tif (value === false) return w.writeUint8(0xf4);\n\n\t\tswitch (typeof value) {\n\t\t\tcase \"number\": {\n\t\t\t\tif (Number.isInteger(value)) {\n\t\t\t\t\tif (value >= 0 && value <= POW_2_53) {\n\t\t\t\t\t\tw.writeMajor(0, value);\n\t\t\t\t\t} else if (value < 0 && value >= -POW_2_53) {\n\t\t\t\t\t\tw.writeMajor(1, -(value + 1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new CborNumberError(\"Number too big to be encoded\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Better precision when encoded as 64-bit\n\t\t\t\t\tw.writeUint8(0xfb);\n\t\t\t\t\tw.writeFloat64(value);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase \"bigint\": {\n\t\t\t\tif (value >= 0 && value < POW_2_64) {\n\t\t\t\t\tw.writeMajor(0, value);\n\t\t\t\t} else if (value <= 0 && value >= -POW_2_64) {\n\t\t\t\t\tw.writeMajor(1, -(value + 1n));\n\t\t\t\t} else {\n\t\t\t\t\tthrow new CborNumberError(\"BigInt too big to be encoded\");\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase \"string\": {\n\t\t\t\ttextEncoder ??= new TextEncoder();\n\t\t\t\tconst encoded = textEncoder.encode(value);\n\t\t\t\tw.writeMajor(3, encoded.byteLength);\n\t\t\t\tw.writeUint8Array(encoded);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tw.writeMajor(4, value.length);\n\t\t\t\t\tfor (const v of value) {\n\t\t\t\t\t\tinner(v);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (value instanceof Tagged) {\n\t\t\t\t\tw.writeMajor(6, value.tag);\n\t\t\t\t\tinner(value.value);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (value instanceof Encoded) {\n\t\t\t\t\tw.writeArrayBuffer(value.encoded);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (value instanceof Gap) {\n\t\t\t\t\tif (fillsMap.has(value)) {\n\t\t\t\t\t\tinner(fillsMap.get(value));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!options.partial) throw new CborPartialDisabled();\n\t\t\t\t\t\tw.chunk(value);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (value instanceof PartiallyEncoded) {\n\t\t\t\t\tconst res = value.build<Partial>(\n\t\t\t\t\t\toptions.fills ?? [],\n\t\t\t\t\t\toptions.partial,\n\t\t\t\t\t);\n\t\t\t\t\tif (options.partial) {\n\t\t\t\t\t\tw.writePartiallyEncoded(res as PartiallyEncoded);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tw.writeArrayBuffer(res as ArrayBuffer);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tvalue instanceof Uint8Array ||\n\t\t\t\t\tvalue instanceof Uint16Array ||\n\t\t\t\t\tvalue instanceof Uint32Array ||\n\t\t\t\t\tvalue instanceof Int8Array ||\n\t\t\t\t\tvalue instanceof Int16Array ||\n\t\t\t\t\tvalue instanceof Int32Array ||\n\t\t\t\t\tvalue instanceof Float32Array ||\n\t\t\t\t\tvalue instanceof Float64Array ||\n\t\t\t\t\tvalue instanceof ArrayBuffer\n\t\t\t\t) {\n\t\t\t\t\tconst v = new Uint8Array(value);\n\t\t\t\t\tw.writeMajor(2, v.byteLength);\n\t\t\t\t\tw.writeUint8Array(v);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst entries =\n\t\t\t\t\tvalue instanceof Map\n\t\t\t\t\t\t? Array.from(value.entries())\n\t\t\t\t\t\t: Object.entries(value);\n\n\t\t\t\tw.writeMajor(5, entries.length);\n\t\t\t\tfor (const v of entries.flat()) {\n\t\t\t\t\tinner(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tinner(input);\n\treturn w.output<Partial>(!!options.partial as Partial, options.replacer);\n}\n", "import { type Major, POW_2_53 } from \"./constants\";\nimport { CborInvalidMajorError, CborRangeError } from \"./error\";\n\nexport class Reader {\n\tprivate _buf: ArrayBufferLike;\n\tprivate _view: DataView;\n\tprivate _byte: Uint8Array;\n\tprivate _pos = 0;\n\n\tconstructor(buffer: ArrayBufferLike) {\n\t\tthis._buf = new ArrayBuffer(buffer.byteLength);\n\t\tthis._view = new DataView(this._buf);\n\t\tthis._byte = new Uint8Array(this._buf);\n\t\tthis._byte.set(new Uint8Array(buffer));\n\t}\n\n\tprivate read<T>(amount: number, res: T): T {\n\t\tthis._pos += amount;\n\t\treturn res;\n\t}\n\n\treadUint8(): number {\n\t\ttry {\n\t\t\treturn this.read(1, this._view.getUint8(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treadUint16(): number {\n\t\ttry {\n\t\t\treturn this.read(2, this._view.getUint16(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treadUint32(): number {\n\t\ttry {\n\t\t\treturn this.read(4, this._view.getUint32(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treadUint64(): bigint {\n\t\ttry {\n\t\t\treturn this.read(8, this._view.getBigUint64(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t// https://stackoverflow.com/a/5684578\n\treadFloat16(): number {\n\t\tconst bytes = this.readUint16();\n\t\tconst s = (bytes & 0x8000) >> 15;\n\t\tconst e = (bytes & 0x7c00) >> 10;\n\t\tconst f = bytes & 0x03ff;\n\n\t\tif (e === 0) {\n\t\t\treturn (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);\n\t\t}\n\n\t\tif (e === 0x1f) {\n\t\t\treturn f ? Number.NaN : (s ? -1 : 1) * Number.POSITIVE_INFINITY;\n\t\t}\n\n\t\treturn (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);\n\t}\n\n\treadFloat32(): number {\n\t\ttry {\n\t\t\treturn this.read(4, this._view.getFloat32(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treadFloat64(): number {\n\t\ttry {\n\t\t\treturn this.read(8, this._view.getFloat64(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treadBytes(amount: number): Uint8Array {\n\t\tconst available = this._byte.length - this._pos;\n\t\tif (available < amount)\n\t\t\tthrow new CborRangeError(\n\t\t\t\t`The argument must be between 0 and ${available}`,\n\t\t\t);\n\n\t\treturn this.read(amount, this._byte.slice(this._pos, this._pos + amount));\n\t}\n\n\treadMajor(): [Major, number] {\n\t\tconst byte = this.readUint8();\n\t\tconst major = (byte >> 5) as Major;\n\t\tif (major < 0 || major > 7)\n\t\t\tthrow new CborInvalidMajorError(\"Received invalid major type\");\n\t\treturn [major, byte & 0x1f];\n\t}\n\n\treadMajorLength(length: number): number | bigint {\n\t\tif (length <= 23) return length;\n\n\t\tswitch (length) {\n\t\t\tcase 24:\n\t\t\t\treturn this.readUint8();\n\t\t\tcase 25:\n\t\t\t\treturn this.readUint16();\n\t\t\tcase 26:\n\t\t\t\treturn this.readUint32();\n\t\t\tcase 27: {\n\t\t\t\tconst read = this.readUint64();\n\t\t\t\treturn read > POW_2_53 ? read : Number(read);\n\t\t\t}\n\t\t}\n\n\t\tthrow new CborRangeError(\"Expected a final length\");\n\t}\n}\n", "import type { Major } from \"./constants\";\nimport { CborInvalidMajorError, CborRangeError } from \"./error\";\nimport type { Reader } from \"./reader\";\nimport { Writer } from \"./writer\";\n\nexport function infiniteBytes(r: Reader, forMajor: Major): ArrayBuffer {\n\tconst w = new Writer();\n\twhile (true) {\n\t\tconst [major, len] = r.readMajor();\n\n\t\t// Received break signal\n\t\tif (major === 7 && len === 31) break;\n\n\t\t// Resource type has to match\n\t\tif (major !== forMajor)\n\t\t\tthrow new CborInvalidMajorError(\n\t\t\t\t`Expected a resource of the same major (${forMajor}) while processing an infinite resource`,\n\t\t\t);\n\n\t\t// Cannot have an infinite resource in an infinite resource\n\t\tif (len === 31)\n\t\t\tthrow new CborRangeError(\n\t\t\t\t\"Expected a finite resource while processing an infinite resource\",\n\t\t\t);\n\n\t\tw.writeUint8Array(r.readBytes(Number(r.readMajorLength(len))));\n\t}\n\n\treturn w.buffer;\n}\n", "import type { Replacer } from \"./constants\";\nimport { CborBreak, CborInvalidMajorError } from \"./error\";\nimport { Reader } from \"./reader\";\nimport { Tagged } from \"./tagged\";\nimport { infiniteBytes } from \"./util\";\n\nlet textDecoder: TextDecoder;\n\nexport interface DecodeOptions {\n\tmap?: \"object\" | \"map\";\n\treplacer?: Replacer;\n}\n\nexport function decode(\n\tinput: ArrayBufferLike | Reader,\n\toptions: DecodeOptions = {},\n\t// biome-ignore lint/suspicious/noExplicitAny: Don't know what it will return\n): any {\n\tconst r = input instanceof Reader ? input : new Reader(input);\n\n\tfunction inner() {\n\t\tconst [major, len] = r.readMajor();\n\t\tswitch (major) {\n\t\t\tcase 0:\n\t\t\t\treturn r.readMajorLength(len);\n\t\t\tcase 1: {\n\t\t\t\tconst l = r.readMajorLength(len);\n\t\t\t\treturn typeof l === \"bigint\" ? -(l + 1n) : -(l + 1);\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tif (len === 31) return infiniteBytes(r, 2);\n\t\t\t\treturn r.readBytes(Number(r.readMajorLength(len))).buffer;\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\tconst encoded =\n\t\t\t\t\tlen === 31\n\t\t\t\t\t\t? infiniteBytes(r, 3)\n\t\t\t\t\t\t: r.readBytes(Number(r.readMajorLength(len)));\n\n\t\t\t\ttextDecoder ??= new TextDecoder();\n\t\t\t\treturn textDecoder.decode(encoded);\n\t\t\t}\n\n\t\t\tcase 4: {\n\t\t\t\tif (len === 31) {\n\t\t\t\t\tconst arr = [];\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tarr.push(decode());\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tif (e instanceof CborBreak) break;\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arr;\n\t\t\t\t}\n\n\t\t\t\tconst l = r.readMajorLength(len);\n\t\t\t\tconst arr = Array(l);\n\t\t\t\tfor (let i = 0; i < l; i++) arr[i] = decode();\n\t\t\t\treturn arr;\n\t\t\t}\n\n\t\t\tcase 5: {\n\t\t\t\tconst entries: [string, unknown][] = [];\n\t\t\t\tif (len === 31) {\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tlet key: string;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tkey = decode();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tif (e instanceof CborBreak) break;\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst value = decode();\n\t\t\t\t\t\tentries.push([key, value]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst l = r.readMajorLength(len);\n\t\t\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\t\t\tconst key = decode();\n\t\t\t\t\t\tconst value = decode();\n\t\t\t\t\t\tentries[i] = [key, value];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn options.map === \"map\"\n\t\t\t\t\t? new Map(entries)\n\t\t\t\t\t: Object.fromEntries(entries);\n\t\t\t}\n\n\t\t\tcase 6: {\n\t\t\t\tconst tag = r.readMajorLength(len);\n\t\t\t\tconst value = decode();\n\t\t\t\treturn new Tagged(tag, value);\n\t\t\t}\n\n\t\t\tcase 7: {\n\t\t\t\tswitch (len) {\n\t\t\t\t\tcase 20:\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tcase 21:\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase 22:\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tcase 23:\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\tcase 25:\n\t\t\t\t\t\treturn r.readFloat16();\n\t\t\t\t\tcase 26:\n\t\t\t\t\t\treturn r.readFloat32();\n\t\t\t\t\tcase 27:\n\t\t\t\t\t\treturn r.readFloat64();\n\t\t\t\t\tcase 31:\n\t\t\t\t\t\tthrow new CborBreak();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new CborInvalidMajorError(\n\t\t\t`Unable to decode value with major tag ${major}`,\n\t\t);\n\t}\n\n\t// biome-ignore lint/suspicious/noExplicitAny: Don't know what it will return\n\tfunction decode(): any {\n\t\treturn options.replacer ? options.replacer(inner()) : inner();\n\t}\n\n\treturn decode();\n}\n", "export function msToNs(ms: number): number {\n\treturn ms * 1000000;\n}\n\nexport function nsToMs(ns: number): number {\n\treturn Math.floor(ns / 1000000);\n}\n\nexport function dateToCborCustomDate(date: Date): [number, number] {\n\tconst s = Math.floor(date.getTime() / 1000);\n\tconst ms = date.getTime() - s * 1000;\n\treturn [s, ms * 1000000];\n}\n\nexport function cborCustomDateToDate([s, ns]: [number, number]): Date {\n\tconst date = new Date(0);\n\tdate.setUTCSeconds(Number(s));\n\tdate.setMilliseconds(Math.floor(Number(ns) / 1000000));\n\treturn date;\n}\n", "/**\n * A complex SurrealQL value type\n */\nexport abstract class Value {\n\t/**\n\t * Compare equality with another value.\n\t */\n\tabstract equals(other: unknown): boolean;\n\n\t/**\n\t * Convert this value to a serializable string\n\t */\n\tabstract toJSON(): unknown;\n\n\t/**\n\t * Convert this value to a string representation\n\t */\n\tabstract toString(): string;\n}\n", "import { Value } from \"../value\";\n\n/**\n * A SurrealQL decimal value.\n */\nexport class Decimal extends Value {\n\treadonly decimal: string;\n\n\tconstructor(decimal: string | number | Decimal) {\n\t\tsuper();\n\t\tthis.decimal = decimal.toString();\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Decimal)) return false;\n\t\treturn this.decimal === other.decimal;\n\t}\n\n\ttoString(): string {\n\t\treturn this.decimal;\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.decimal;\n\t}\n}\n", "import { SurrealDbError } from \"../../errors\";\nimport { Value } from \"../value\";\n\nconst millisecond = 1;\nconst microsecond = millisecond / 1000;\nconst nanosecond = microsecond / 1000;\nconst second = 1000 * millisecond;\nconst minute = 60 * second;\nconst hour = 60 * minute;\nconst day = 24 * hour;\nconst week = 7 * day;\n\nconst units = new Map([\n\t[\"ns\", nanosecond],\n\t[\"\u00B5s\", microsecond],\n\t[\"\u03BCs\", microsecond], // They look similar, but this unit is a different charachter than the one above it.\n\t[\"us\", microsecond], // needs to come last to be the displayed unit\n\t[\"ms\", millisecond],\n\t[\"s\", second],\n\t[\"m\", minute],\n\t[\"h\", hour],\n\t[\"d\", day],\n\t[\"w\", week],\n]);\n\nconst unitsReverse = Array.from(units).reduce((map, [unit, size]) => {\n\tmap.set(size, unit);\n\treturn map;\n}, new Map<number, string>());\n\nconst durationPartRegex = new RegExp(\n\t`^(\\\\d+)(${Array.from(units.keys()).join(\"|\")})`,\n);\n\n/**\n * A SurrealQL duration value.\n */\nexport class Duration extends Value {\n\treadonly _milliseconds: number;\n\n\tconstructor(input: Duration | number | string) {\n\t\tsuper();\n\n\t\tif (input instanceof Duration) {\n\t\t\tthis._milliseconds = input._milliseconds;\n\t\t} else if (typeof input === \"string\") {\n\t\t\tthis._milliseconds = Duration.parseString(input);\n\t\t} else {\n\t\t\tthis._milliseconds = input;\n\t\t}\n\t}\n\n\tstatic fromCompact([s, ns]: [number, number] | [number] | []): Duration {\n\t\ts = s ?? 0;\n\t\tns = ns ?? 0;\n\t\tconst ms = s * 1000 + ns / 1000000;\n\t\treturn new Duration(ms);\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Duration)) return false;\n\t\treturn this._milliseconds === other._milliseconds;\n\t}\n\n\ttoCompact(): [number, number] | [number] | [] {\n\t\tconst s = Math.floor(this._milliseconds / 1000);\n\t\tconst ns = Math.floor((this._milliseconds - s * 1000) * 1000000);\n\t\treturn ns > 0 ? [s, ns] : s > 0 ? [s] : [];\n\t}\n\n\ttoString(): string {\n\t\tlet left = this._milliseconds;\n\t\tlet result = \"\";\n\t\tfunction scrap(size: number) {\n\t\t\tconst num = Math.floor(left / size);\n\t\t\tif (num > 0) left = left % size;\n\t\t\treturn num;\n\t\t}\n\n\t\tfor (const [size, unit] of Array.from(unitsReverse).reverse()) {\n\t\t\tconst scrapped = scrap(size);\n\t\t\tif (scrapped > 0) result += `${scrapped}${unit}`;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.toString();\n\t}\n\n\tstatic parseString(input: string): number {\n\t\tlet ms = 0;\n\t\tlet left = input;\n\t\twhile (left !== \"\") {\n\t\t\tconst match = left.match(durationPartRegex);\n\t\t\tif (match) {\n\t\t\t\tconst amount = Number.parseInt(match[1]);\n\t\t\t\tconst factor = units.get(match[2]);\n\t\t\t\tif (factor === undefined)\n\t\t\t\t\tthrow new SurrealDbError(`Invalid duration unit: ${match[2]}`);\n\n\t\t\t\tms += amount * factor;\n\t\t\t\tleft = left.slice(match[0].length);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow new SurrealDbError(\"Could not match a next duration part\");\n\t\t}\n\n\t\treturn ms;\n\t}\n\n\tstatic nanoseconds(nanoseconds: number): Duration {\n\t\treturn new Duration(Math.floor(nanoseconds * nanosecond));\n\t}\n\n\tstatic microseconds(microseconds: number): Duration {\n\t\treturn new Duration(Math.floor(microseconds * microsecond));\n\t}\n\n\tstatic milliseconds(milliseconds: number): Duration {\n\t\treturn new Duration(milliseconds);\n\t}\n\n\tstatic seconds(seconds: number): Duration {\n\t\treturn new Duration(seconds * second);\n\t}\n\n\tstatic minutes(minutes: number): Duration {\n\t\treturn new Duration(minutes * minute);\n\t}\n\n\tstatic hours(hours: number): Duration {\n\t\treturn new Duration(hours * hour);\n\t}\n\n\tstatic days(days: number): Duration {\n\t\treturn new Duration(days * day);\n\t}\n\n\tstatic weeks(weeks: number): Duration {\n\t\treturn new Duration(weeks * week);\n\t}\n\n\tget microseconds(): number {\n\t\treturn Math.floor(this._milliseconds / microsecond);\n\t}\n\n\tget nanoseconds(): number {\n\t\treturn Math.floor(this._milliseconds / nanosecond);\n\t}\n\n\tget milliseconds(): number {\n\t\treturn Math.floor(this._milliseconds);\n\t}\n\n\tget seconds(): number {\n\t\treturn Math.floor(this._milliseconds / second);\n\t}\n\n\tget minutes(): number {\n\t\treturn Math.floor(this._milliseconds / minute);\n\t}\n\n\tget hours(): number {\n\t\treturn Math.floor(this._milliseconds / hour);\n\t}\n\n\tget days(): number {\n\t\treturn Math.floor(this._milliseconds / day);\n\t}\n\n\tget weeks(): number {\n\t\treturn Math.floor(this._milliseconds / week);\n\t}\n}\n", "import { Value } from \"../value\";\n\n/**\n * An uncomputed SurrealQL future value.\n */\nexport class Future extends Value {\n\tconstructor(readonly inner: string) {\n\t\tsuper();\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Future)) return false;\n\t\treturn this.inner === other.inner;\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.toString();\n\t}\n\n\ttoString(): string {\n\t\treturn `<future> ${this.inner}`;\n\t}\n}\n", "import { Value } from \"../value.ts\";\nimport { Decimal } from \"./decimal.ts\";\n\n/**\n * A SurrealQL geometry value.\n */\nexport abstract class Geometry extends Value {\n\tabstract toJSON(): GeoJson;\n\tabstract is(geometry: Geometry): boolean;\n\tabstract clone(): Geometry;\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Geometry)) return false;\n\t\treturn this.is(other);\n\t}\n\n\ttoString(): string {\n\t\treturn JSON.stringify(this.toJSON());\n\t}\n}\n\nfunction f(num: number | Decimal) {\n\tif (num instanceof Decimal) return Number.parseFloat(num.decimal);\n\treturn num;\n}\n\n/**\n * A SurrealQL point geometry value.\n */\nexport class GeometryPoint extends Geometry {\n\treadonly point: [number, number];\n\n\tconstructor(point: [number | Decimal, number | Decimal] | GeometryPoint) {\n\t\tsuper();\n\t\tif (point instanceof GeometryPoint) {\n\t\t\tthis.point = point.clone().point;\n\t\t} else {\n\t\t\tthis.point = [f(point[0]), f(point[1])];\n\t\t}\n\t}\n\n\ttoJSON(): GeoJsonPoint {\n\t\treturn {\n\t\t\ttype: \"Point\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonPoint[\"coordinates\"] {\n\t\treturn this.point;\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryPoint {\n\t\tif (!(geometry instanceof GeometryPoint)) return false;\n\t\treturn (\n\t\t\tthis.point[0] === geometry.point[0] && this.point[1] === geometry.point[1]\n\t\t);\n\t}\n\n\tclone(): GeometryPoint {\n\t\treturn new GeometryPoint([...this.point]);\n\t}\n}\n\n/**\n * A SurrealQL line geometry value.\n */\nexport class GeometryLine extends Geometry {\n\treadonly line: [GeometryPoint, GeometryPoint, ...GeometryPoint[]];\n\n\t// SurrealDB only has the concept of a \"Line\", which by spec is two points.\n\t// SurrealDB's \"Line\" however, is actually a \"LineString\" under the hood, which accepts two or more points\n\tconstructor(\n\t\tline: [GeometryPoint, GeometryPoint, ...GeometryPoint[]] | GeometryLine,\n\t) {\n\t\tsuper();\n\t\tthis.line = line instanceof GeometryLine ? line.clone().line : line;\n\t}\n\n\ttoJSON(): GeoJsonLineString {\n\t\treturn {\n\t\t\ttype: \"LineString\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonLineString[\"coordinates\"] {\n\t\treturn this.line.map(\n\t\t\t(g) => g.coordinates,\n\t\t) as GeoJsonLineString[\"coordinates\"];\n\t}\n\n\tclose(): void {\n\t\tif (!this.line[0].is(this.line.at(-1) as GeometryPoint)) {\n\t\t\tthis.line.push(this.line[0]);\n\t\t}\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryLine {\n\t\tif (!(geometry instanceof GeometryLine)) return false;\n\t\tif (this.line.length !== geometry.line.length) return false;\n\t\tfor (let i = 0; i < this.line.length; i++) {\n\t\t\tif (!this.line[i].is(geometry.line[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryLine {\n\t\treturn new GeometryLine(\n\t\t\tthis.line.map((p) => p.clone()) as [\n\t\t\t\tGeometryPoint,\n\t\t\t\tGeometryPoint,\n\t\t\t\t...GeometryPoint[],\n\t\t\t],\n\t\t);\n\t}\n}\n\n/**\n * A SurrealQL polygon geometry value.\n */\nexport class GeometryPolygon extends Geometry {\n\treadonly polygon: [GeometryLine, ...GeometryLine[]];\n\n\tconstructor(polygon: [GeometryLine, ...GeometryLine[]] | GeometryPolygon) {\n\t\tsuper();\n\t\tthis.polygon =\n\t\t\tpolygon instanceof GeometryPolygon\n\t\t\t\t? polygon.clone().polygon\n\t\t\t\t: (polygon.map((l) => {\n\t\t\t\t\t\tconst line = l.clone();\n\t\t\t\t\t\tline.close();\n\t\t\t\t\t\treturn line;\n\t\t\t\t\t}) as [GeometryLine, ...GeometryLine[]]);\n\t}\n\n\ttoJSON(): GeoJsonPolygon {\n\t\treturn {\n\t\t\ttype: \"Polygon\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonPolygon[\"coordinates\"] {\n\t\treturn this.polygon.map(\n\t\t\t(g) => g.coordinates,\n\t\t) as GeoJsonPolygon[\"coordinates\"];\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryPolygon {\n\t\tif (!(geometry instanceof GeometryPolygon)) return false;\n\t\tif (this.polygon.length !== geometry.polygon.length) return false;\n\t\tfor (let i = 0; i < this.polygon.length; i++) {\n\t\t\tif (!this.polygon[i].is(geometry.polygon[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryPolygon {\n\t\treturn new GeometryPolygon(\n\t\t\tthis.polygon.map((p) => p.clone()) as [GeometryLine, ...GeometryLine[]],\n\t\t);\n\t}\n}\n\n/**\n * A SurrealQL multi-point geometry value.\n */\nexport class GeometryMultiPoint extends Geometry {\n\treadonly points: [GeometryPoint, ...GeometryPoint[]];\n\n\tconstructor(\n\t\tpoints: [GeometryPoint, ...GeometryPoint[]] | GeometryMultiPoint,\n\t) {\n\t\tsuper();\n\t\tthis.points = points instanceof GeometryMultiPoint ? points.points : points;\n\t}\n\n\ttoJSON(): GeoJsonMultiPoint {\n\t\treturn {\n\t\t\ttype: \"MultiPoint\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonMultiPoint[\"coordinates\"] {\n\t\treturn this.points.map(\n\t\t\t(g) => g.coordinates,\n\t\t) as GeoJsonMultiPoint[\"coordinates\"];\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryMultiPoint {\n\t\tif (!(geometry instanceof GeometryMultiPoint)) return false;\n\t\tif (this.points.length !== geometry.points.length) return false;\n\t\tfor (let i = 0; i < this.points.length; i++) {\n\t\t\tif (!this.points[i].is(geometry.points[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryMultiPoint {\n\t\treturn new GeometryMultiPoint(\n\t\t\tthis.points.map((p) => p.clone()) as [GeometryPoint, ...GeometryPoint[]],\n\t\t);\n\t}\n}\n\n/**\n * A SurrealQL multi-line geometry value.\n */\nexport class GeometryMultiLine extends Geometry {\n\treadonly lines: [GeometryLine, ...GeometryLine[]];\n\n\tconstructor(lines: [GeometryLine, ...GeometryLine[]] | GeometryMultiLine) {\n\t\tsuper();\n\t\tthis.lines = lines instanceof GeometryMultiLine ? lines.lines : lines;\n\t}\n\n\ttoJSON(): GeoJsonMultiLineString {\n\t\treturn {\n\t\t\ttype: \"MultiLineString\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonMultiLineString[\"coordinates\"] {\n\t\treturn this.lines.map(\n\t\t\t(g) => g.coordinates,\n\t\t) as GeoJsonMultiLineString[\"coordinates\"];\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryMultiLine {\n\t\tif (!(geometry instanceof GeometryMultiLine)) return false;\n\t\tif (this.lines.length !== geometry.lines.length) return false;\n\t\tfor (let i = 0; i < this.lines.length; i++) {\n\t\t\tif (!this.lines[i].is(geometry.lines[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryMultiLine {\n\t\treturn new GeometryMultiLine(\n\t\t\tthis.lines.map((p) => p.clone()) as [GeometryLine, ...GeometryLine[]],\n\t\t);\n\t}\n}\n\n/**\n * A SurrealQL multi-polygon geometry value.\n */\nexport class GeometryMultiPolygon extends Geometry {\n\treadonly polygons: [GeometryPolygon, ...GeometryPolygon[]];\n\n\tconstructor(\n\t\tpolygons: [GeometryPolygon, ...GeometryPolygon[]] | GeometryMultiPolygon,\n\t) {\n\t\tsuper();\n\t\tthis.polygons =\n\t\t\tpolygons instanceof GeometryMultiPolygon ? polygons.polygons : polygons;\n\t}\n\n\ttoJSON(): GeoJsonMultiPolygon {\n\t\treturn {\n\t\t\ttype: \"MultiPolygon\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonMultiPolygon[\"coordinates\"] {\n\t\treturn this.polygons.map(\n\t\t\t(g) => g.coordinates,\n\t\t) as GeoJsonMultiPolygon[\"coordinates\"];\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryMultiPolygon {\n\t\tif (!(geometry instanceof GeometryMultiPolygon)) return false;\n\t\tif (this.polygons.length !== geometry.polygons.length) return false;\n\t\tfor (let i = 0; i < this.polygons.length; i++) {\n\t\t\tif (!this.polygons[i].is(geometry.polygons[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryMultiPolygon {\n\t\treturn new GeometryMultiPolygon(\n\t\t\tthis.polygons.map((p) => p.clone()) as [\n\t\t\t\tGeometryPolygon,\n\t\t\t\t...GeometryPolygon[],\n\t\t\t],\n\t\t);\n\t}\n}\n\n/**\n * A SurrealQL geometry collection value.\n */\nexport class GeometryCollection extends Geometry {\n\treadonly collection: [Geometry, ...Geometry[]];\n\n\tconstructor(collection: [Geometry, ...Geometry[]] | GeometryCollection) {\n\t\tsuper();\n\t\tthis.collection =\n\t\t\tcollection instanceof GeometryCollection\n\t\t\t\t? collection.collection\n\t\t\t\t: collection;\n\t}\n\n\ttoJSON(): GeoJsonCollection {\n\t\treturn {\n\t\t\ttype: \"GeometryCollection\" as const,\n\t\t\tgeometries: this.geometries,\n\t\t};\n\t}\n\n\tget geometries(): GeoJsonCollection[\"geometries\"] {\n\t\treturn this.collection.map((g) =>\n\t\t\tg.toJSON(),\n\t\t) as GeoJsonCollection[\"geometries\"];\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryCollection {\n\t\tif (!(geometry instanceof GeometryCollection)) return false;\n\t\tif (this.collection.length !== geometry.collection.length) return false;\n\t\tfor (let i = 0; i < this.collection.length; i++) {\n\t\t\tif (!this.collection[i].is(geometry.collection[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryCollection {\n\t\treturn new GeometryCollection(\n\t\t\tthis.collection.map((p) => p.clone()) as [Geometry, ...Geometry[]],\n\t\t);\n\t}\n}\n\n// Geo Json Types\n\ntype GeoJson =\n\t| GeoJsonPoint\n\t| GeoJsonLineString\n\t| GeoJsonPolygon\n\t| GeoJsonMultiPoint\n\t| GeoJsonMultiLineString\n\t| GeoJsonMultiPolygon\n\t| GeoJsonCollection;\n\nexport type GeoJsonPoint = {\n\ttype: \"Point\";\n\tcoordinates: [number, number];\n};\n\nexport type GeoJsonLineString = {\n\ttype: \"LineString\";\n\tcoordinates: [\n\t\tGeoJsonPoint[\"coordinates\"],\n\t\tGeoJsonPoint[\"coordinates\"],\n\t\t...GeoJsonPoint[\"coordinates\"][],\n\t];\n};\n\nexport type GeoJsonPolygon = {\n\ttype: \"Polygon\";\n\tcoordinates: [\n\t\tGeoJsonLineString[\"coordinates\"],\n\t\t...GeoJsonLineString[\"coordinates\"][],\n\t];\n};\n\nexport type GeoJsonMultiPoint = {\n\ttype: \"MultiPoint\";\n\tcoordinates: [GeoJsonPoint[\"coordinates\"], ...GeoJsonPoint[\"coordinates\"][]];\n};\n\nexport type GeoJsonMultiLineString = {\n\ttype: \"MultiLineString\";\n\tcoordinates: [\n\t\tGeoJsonLineString[\"coordinates\"],\n\t\t...GeoJsonLineString[\"coordinates\"][],\n\t];\n};\n\nexport type GeoJsonMultiPolygon = {\n\ttype: \"MultiPolygon\";\n\tcoordinates: [\n\t\tGeoJsonPolygon[\"coordinates\"],\n\t\t...GeoJsonPolygon[\"coordinates\"][],\n\t];\n};\n\nexport type GeoJsonCollection = {\n\ttype: \"GeometryCollection\";\n\tgeometries: GeoJson[];\n};\n", "import { Value } from \"../data/value\";\n\n/**\n * Recursively compare supported SurrealQL values for equality.\n *\n * @param x The first value to compare\n * @param y The second value to compare\n * @returns Whether the two values are recursively equal\n */\nexport function equals(x: unknown, y: unknown): boolean {\n\tif (Object.is(x, y)) return true;\n\tif (x instanceof Date && y instanceof Date) {\n\t\treturn x.getTime() === y.getTime();\n\t}\n\tif (x instanceof RegExp && y instanceof RegExp) {\n\t\treturn x.toString() === y.toString();\n\t}\n\tif (x instanceof Value && y instanceof Value) {\n\t\treturn x.equals(y);\n\t}\n\tif (\n\t\ttypeof x !== \"object\" ||\n\t\tx === null ||\n\t\ttypeof y !== \"object\" ||\n\t\ty === null\n\t) {\n\t\treturn false;\n\t}\n\tconst keysX = Reflect.ownKeys(x as unknown as object) as (keyof typeof x)[];\n\tconst keysY = Reflect.ownKeys(y as unknown as object);\n\tif (keysX.length !== keysY.length) return false;\n\tfor (let i = 0; i < keysX.length; i++) {\n\t\tif (!Reflect.has(y as unknown as object, keysX[i])) return false;\n\t\tif (!equals(x[keysX[i]], y[keysX[i]])) return false;\n\t}\n\treturn true;\n}\n", "const MAX_i64 = 9223372036854775807n;\n/**\n * Escape a given string to be used as a valid SurrealQL ident.\n * @param str - The string to escape\n * @returns Optionally escaped string\n */\nexport function escapeIdent(str) {\n    // String which looks like a number should always be escaped, to prevent it from being parsed as a number\n    if (isOnlyNumbers(str)) {\n        return `\u27E8${str}\u27E9`;\n    }\n    // Empty string should always be escaped\n    if (str === \"\") {\n        return \"\u27E8\u27E9\";\n    }\n    let code;\n    let i;\n    let len;\n    for (i = 0, len = str.length; i < len; i++) {\n        code = str.charCodeAt(i);\n        if (!(code > 47 && code < 58) && // numeric (0-9)\n            !(code > 64 && code < 91) && // upper alpha (A-Z)\n            !(code > 96 && code < 123) && // lower alpha (a-z)\n            !(code === 95) // underscore (_)\n        ) {\n            return `\u27E8${str.replaceAll(\"\u27E9\", \"\\\\\u27E9\")}\u27E9`;\n        }\n    }\n    return str;\n}\n/**\n * Escape a given string to be used as a valid SurrealQL ident.\n * @param str - The string to escape\n * @returns Optionally escaped string\n * @deprecated Use `escapeIdent` instead\n */\nexport function escape_ident(str) {\n    return escapeIdent(str);\n}\n/**\n * Escape a number to be used as a valid SurrealQL ident.\n * @param num - The number to escape\n * @returns Optionally escaped number\n */\nexport function escapeNumber(num) {\n    return num <= MAX_i64 ? num.toString() : `\u27E8${num}\u27E9`;\n}\nfunction isOnlyNumbers(str) {\n    return /^\\d+$/.test(str.replace(/_/g, \"\"));\n}\n", "import { UUID, uuidv4obj, uuidv7obj } from \"uuidv7\";\nimport { Value } from \"../value\";\n\n/**\n * A SurrealQL UUID value.\n */\nexport class Uuid extends Value {\n\tprivate readonly inner: UUID;\n\n\tconstructor(uuid: string | ArrayBuffer | Uint8Array | Uuid | UUID) {\n\t\tsuper();\n\n\t\tif (uuid instanceof ArrayBuffer) {\n\t\t\tthis.inner = UUID.ofInner(new Uint8Array(uuid));\n\t\t} else if (uuid instanceof Uint8Array) {\n\t\t\tthis.inner = UUID.ofInner(uuid);\n\t\t} else if (uuid instanceof Uuid) {\n\t\t\tthis.inner = uuid.inner;\n\t\t} else if (uuid instanceof UUID) {\n\t\t\tthis.inner = uuid;\n\t\t} else {\n\t\t\tthis.inner = UUID.parse(uuid);\n\t\t}\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Uuid)) return false;\n\t\treturn this.inner.equals(other.inner);\n\t}\n\n\ttoString(): string {\n\t\treturn this.inner.toString();\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.inner.toString();\n\t}\n\n\ttoUint8Array(): Uint8Array {\n\t\treturn this.inner.bytes;\n\t}\n\n\ttoBuffer(): ArrayBufferLike {\n\t\treturn this.inner.bytes.buffer;\n\t}\n\n\tstatic v4(): Uuid {\n\t\treturn new Uuid(uuidv4obj());\n\t}\n\n\tstatic v7(): Uuid {\n\t\treturn new Uuid(uuidv7obj());\n\t}\n}\n", "import { SurrealDbError } from \"../../errors\";\nimport { equals } from \"../../util/equals\";\nimport { escapeIdent, escapeNumber } from \"../../util/escape\";\nimport { toSurrealqlString } from \"../../util/to-surrealql-string\";\nimport { Value } from \"../value\";\nimport { Uuid } from \"./uuid\";\n\nexport type RecordIdValue =\n\t| string\n\t| number\n\t| Uuid\n\t| bigint\n\t| unknown[]\n\t| Record<string, unknown>;\n\n/**\n * A SurrealQL record ID value.\n */\nexport class RecordId<Tb extends string = string> extends Value {\n\tpublic readonly tb: Tb;\n\tpublic readonly id: RecordIdValue;\n\n\tconstructor(tb: Tb, id: RecordIdValue) {\n\t\tsuper();\n\n\t\tif (typeof tb !== \"string\")\n\t\t\tthrow new SurrealDbError(\"TB part is not valid\");\n\t\tif (!isValidIdPart(id)) throw new SurrealDbError(\"ID part is not valid\");\n\n\t\tthis.tb = tb;\n\t\tthis.id = id;\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof RecordId)) return false;\n\t\treturn this.tb === other.tb && equals(this.id, other.id);\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.toString();\n\t}\n\n\ttoString(): string {\n\t\tconst tb = escapeIdent(this.tb);\n\t\tconst id = escapeIdPart(this.id);\n\t\treturn `${tb}:${id}`;\n\t}\n}\n\n/**\n * A SurrealQL string-represented record ID value.\n */\nexport class StringRecordId extends Value {\n\tpublic readonly rid: string;\n\n\tconstructor(rid: string | StringRecordId | RecordId) {\n\t\tsuper();\n\n\t\t// In some cases the same method may be used with different data sources\n\t\t// this can cause this method to be called with an already instanced class object.\n\t\tif (rid instanceof StringRecordId) {\n\t\t\tthis.rid = rid.rid;\n\t\t} else if (rid instanceof RecordId) {\n\t\t\tthis.rid = rid.toString();\n\t\t} else if (typeof rid === \"string\") {\n\t\t\tthis.rid = rid;\n\t\t} else {\n\t\t\tthrow new SurrealDbError(\"String Record ID must be a string\");\n\t\t}\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof StringRecordId)) return false;\n\t\treturn this.rid === other.rid;\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.rid;\n\t}\n\n\ttoString(): string {\n\t\treturn this.rid;\n\t}\n}\n\nexport function isValidIdPart(v: unknown): v is RecordIdValue {\n\tif (v instanceof Uuid) return true;\n\n\tswitch (typeof v) {\n\t\tcase \"string\":\n\t\tcase \"number\":\n\t\tcase \"bigint\":\n\t\t\treturn true;\n\t\tcase \"object\":\n\t\t\treturn Array.isArray(v) || v !== null;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nexport function escapeIdPart(id: RecordIdValue): string {\n\treturn id instanceof Uuid\n\t\t? `u\"${id}\"`\n\t\t: typeof id === \"string\"\n\t\t\t? escapeIdent(id)\n\t\t\t: typeof id === \"bigint\" || typeof id === \"number\"\n\t\t\t\t? escapeNumber(id)\n\t\t\t\t: toSurrealqlString(id);\n}\n", "import { SurrealDbError } from \"../../errors\";\nimport { Value } from \"../value\";\n\n/**\n * A SurrealQL table value.\n */\nexport class Table<Tb extends string = string> extends Value {\n\tpublic readonly tb: Tb;\n\n\tconstructor(tb: Tb) {\n\t\tsuper();\n\t\tif (typeof tb !== \"string\")\n\t\t\tthrow new SurrealDbError(\"Table must be a string\");\n\t\tthis.tb = tb;\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Table)) return false;\n\t\treturn this.tb === other.tb;\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.tb;\n\t}\n\n\ttoString(): string {\n\t\treturn this.tb;\n\t}\n}\n", "import {\n\tDecimal,\n\tDuration,\n\tFuture,\n\tGeometry,\n\tRange,\n\tRecordId,\n\tStringRecordId,\n\tTable,\n\tUuid,\n} from \"../data\";\n\n/**\n * Recursively print any supported SurrealQL value into a string representation.\n * @param input - The input value\n * @returns Stringified SurrealQL representation\n */\nexport function toSurrealqlString(input: unknown): string {\n\tif (typeof input === \"string\") return `s${JSON.stringify(input)}`;\n\tif (input === null) return \"NULL\";\n\tif (input === undefined) return \"NONE\";\n\n\tif (typeof input === \"object\") {\n\t\t// We explicitely use string prefixes to ensure compability with both SurrealDB 1.x and 2.x\n\t\tif (input instanceof Date) return `d${JSON.stringify(input.toISOString())}`;\n\t\tif (input instanceof Uuid) return `u${JSON.stringify(input.toString())}`;\n\t\tif (input instanceof RecordId || input instanceof StringRecordId)\n\t\t\treturn `r${JSON.stringify(input.toString())}`;\n\n\t\tif (input instanceof Geometry) return toSurrealqlString(input.toJSON());\n\n\t\tif (\n\t\t\tinput instanceof Decimal ||\n\t\t\tinput instanceof Duration ||\n\t\t\tinput instanceof Future ||\n\t\t\tinput instanceof Range ||\n\t\t\tinput instanceof Table\n\t\t) {\n\t\t\treturn input.toJSON();\n\t\t}\n\n\t\t// We check by prototype, because we do not want to process derivatives of objects and arrays\n\t\tswitch (Object.getPrototypeOf(input)) {\n\t\t\tcase Object.prototype: {\n\t\t\t\tlet output = \"{ \";\n\t\t\t\tconst entries = Object.entries(input as object);\n\t\t\t\tfor (const [i, [k, v]] of entries.entries()) {\n\t\t\t\t\toutput += `${JSON.stringify(k)}: ${toSurrealqlString(v)}`;\n\t\t\t\t\tif (i < entries.length - 1) output += \", \";\n\t\t\t\t}\n\t\t\t\toutput += \" }\";\n\t\t\t\treturn output;\n\t\t\t}\n\t\t\tcase Map.prototype: {\n\t\t\t\tlet output = \"{ \";\n\t\t\t\tconst entries = Array.from((input as Map<unknown, unknown>).entries());\n\t\t\t\tfor (const [i, [k, v]] of entries.entries()) {\n\t\t\t\t\toutput += `${JSON.stringify(k)}: ${toSurrealqlString(v)}`;\n\t\t\t\t\tif (i < entries.length - 1) output += \", \";\n\t\t\t\t}\n\t\t\t\toutput += \" }\";\n\t\t\t\treturn output;\n\t\t\t}\n\t\t\tcase Array.prototype: {\n\t\t\t\tconst array = (input as unknown[]).map(toSurrealqlString);\n\t\t\t\treturn `[ ${array.join(\", \")} ]`;\n\t\t\t}\n\t\t\tcase Set.prototype: {\n\t\t\t\tconst set = new Set([...(input as [])].map(toSurrealqlString));\n\t\t\t\treturn `[ ${[...set].join(\", \")} ]`;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn `${input}`;\n}\n", "import { Tagged } from \"../../cbor\";\nimport { SurrealDbError } from \"../../errors\";\nimport { equals } from \"../../util/equals\";\nimport { escapeIdent } from \"../../util/escape\";\nimport { toSurrealqlString } from \"../../util/to-surrealql-string\";\nimport { TAG_BOUND_EXCLUDED, TAG_BOUND_INCLUDED } from \"../cbor\";\nimport { Value } from \"../value\";\nimport { type RecordIdValue, escapeIdPart, isValidIdPart } from \"./recordid\";\n\n/**\n * A SurrealQL range value.\n */\nexport class Range<Beg, End> extends Value {\n\tconstructor(\n\t\treadonly beg: Bound<Beg>,\n\t\treadonly end: Bound<End>,\n\t) {\n\t\tsuper();\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Range)) return false;\n\t\tif (this.beg?.constructor !== other.beg?.constructor) return false;\n\t\tif (this.end?.constructor !== other.end?.constructor) return false;\n\t\treturn (\n\t\t\tequals(this.beg?.value, other.beg?.value) &&\n\t\t\tequals(this.end?.value, other.end?.value)\n\t\t);\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.toString();\n\t}\n\n\ttoString(): string {\n\t\tconst beg = escapeRangeBound(this.beg);\n\t\tconst end = escapeRangeBound(this.end);\n\t\treturn `${beg}${getRangeJoin(this.beg, this.end)}${end}`;\n\t}\n}\n\nexport type Bound<T> = BoundIncluded<T> | BoundExcluded<T> | undefined;\ntype DecodedBound = BoundIncluded<unknown> | BoundExcluded<unknown> | null;\nexport class BoundIncluded<T> {\n\tconstructor(readonly value: T) {}\n}\n\nexport class BoundExcluded<T> {\n\tconstructor(readonly value: T) {}\n}\n\n/**\n * A SurrealQL record ID range value.\n */\nexport class RecordIdRange<Tb extends string = string> extends Value {\n\tconstructor(\n\t\tpublic readonly tb: Tb,\n\t\tpublic readonly beg: Bound<RecordIdValue>,\n\t\tpublic readonly end: Bound<RecordIdValue>,\n\t) {\n\t\tsuper();\n\t\tif (typeof tb !== \"string\")\n\t\t\tthrow new SurrealDbError(\"TB part is not valid\");\n\t\tif (!isValidIdBound(beg)) throw new SurrealDbError(\"Beg part is not valid\");\n\t\tif (!isValidIdBound(end)) throw new SurrealDbError(\"End part is not valid\");\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof RecordIdRange)) return false;\n\t\tif (this.beg?.constructor !== other.beg?.constructor) return false;\n\t\tif (this.end?.constructor !== other.end?.constructor) return false;\n\t\treturn (\n\t\t\tthis.tb === other.tb &&\n\t\t\tequals(this.beg?.value, other.beg?.value) &&\n\t\t\tequals(this.end?.value, other.end?.value)\n\t\t);\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.toString();\n\t}\n\n\ttoString(): string {\n\t\tconst tb = escapeIdent(this.tb);\n\t\tconst beg = escapeIdBound(this.beg);\n\t\tconst end = escapeIdBound(this.end);\n\t\treturn `${tb}:${beg}${getRangeJoin(this.beg, this.end)}${end}`;\n\t}\n}\n\nfunction getRangeJoin(beg: Bound<unknown>, end: Bound<unknown>): string {\n\tlet output = \"\";\n\tif (beg instanceof BoundExcluded) output += \">\";\n\toutput += \"..\";\n\tif (end instanceof BoundIncluded) output += \"=\";\n\treturn output;\n}\n\nfunction isValidIdBound(bound: Bound<unknown>): bound is Bound<RecordIdValue> {\n\treturn bound instanceof BoundIncluded || bound instanceof BoundExcluded\n\t\t? isValidIdPart(bound.value)\n\t\t: true;\n}\n\nfunction escapeIdBound(bound: Bound<RecordIdValue>): string {\n\treturn bound instanceof BoundIncluded || bound instanceof BoundExcluded\n\t\t? escapeIdPart(bound.value)\n\t\t: \"\";\n}\n\nfunction escapeRangeBound(bound: Bound<unknown>): string {\n\tif (bound === undefined) return \"\";\n\tconst value = bound.value;\n\n\tif (bound instanceof Range) return `(${toSurrealqlString(value)})`;\n\treturn toSurrealqlString(value);\n}\n\nexport function rangeToCbor([beg, end]: [Bound<unknown>, Bound<unknown>]): [\n\tTagged | null,\n\tTagged | null,\n] {\n\tfunction encodeBound(bound: Bound<unknown>): Tagged | null {\n\t\tif (bound instanceof BoundIncluded)\n\t\t\treturn new Tagged(TAG_BOUND_INCLUDED, bound.value);\n\t\tif (bound instanceof BoundExcluded)\n\t\t\treturn new Tagged(TAG_BOUND_EXCLUDED, bound.value);\n\t\treturn null;\n\t}\n\n\treturn [encodeBound(beg), encodeBound(end)];\n}\n\nexport function cborToRange(\n\trange: [DecodedBound | null, DecodedBound | null],\n): [Bound<unknown>, Bound<unknown>] {\n\tfunction decodeBound(bound: DecodedBound | null): Bound<unknown> {\n\t\tif (bound === null) return undefined;\n\t\tif (bound instanceof BoundIncluded) return bound;\n\t\tif (bound instanceof BoundExcluded) return bound;\n\t\tthrow new SurrealDbError(\"Expected the bounds to be decoded already\");\n\t}\n\n\treturn [decodeBound(range[0]), decodeBound(range[1])];\n}\n", "import { Tagged, decode, encode } from \"../cbor\";\nimport {\n\tcborCustomDateToDate,\n\tdateToCborCustomDate,\n} from \"./types/datetime.ts\";\nimport { Decimal } from \"./types/decimal.ts\";\nimport { Duration } from \"./types/duration.ts\";\nimport { Future } from \"./types/future.ts\";\nimport {\n\tGeometryCollection,\n\tGeometryLine,\n\tGeometryMultiLine,\n\tGeometryMultiPoint,\n\tGeometryMultiPolygon,\n\tGeometryPoint,\n\tGeometryPolygon,\n} from \"./types/geometry.ts\";\nimport {\n\tBoundExcluded,\n\tBoundIncluded,\n\tRange,\n\tRecordIdRange,\n\tcborToRange,\n\trangeToCbor,\n} from \"./types/range.ts\";\nimport { RecordId, StringRecordId } from \"./types/recordid.ts\";\nimport { Table } from \"./types/table.ts\";\nimport { Uuid } from \"./types/uuid.ts\";\n\n// Tags from the spec - https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml\nconst TAG_SPEC_DATETIME = 0;\nconst TAG_SPEC_UUID = 37;\n\n// Custom tags\nconst TAG_NONE = 6;\nconst TAG_TABLE = 7;\nconst TAG_RECORDID = 8;\nconst TAG_STRING_UUID = 9;\nconst TAG_STRING_DECIMAL = 10;\n// const TAG_BINARY_DECIMAL = 11;\nconst TAG_CUSTOM_DATETIME = 12;\nconst TAG_STRING_DURATION = 13;\nconst TAG_CUSTOM_DURATION = 14;\nconst TAG_FUTURE = 15;\n\n// Ranges\nexport const TAG_RANGE = 49;\nexport const TAG_BOUND_INCLUDED = 50;\nexport const TAG_BOUND_EXCLUDED = 51;\n\n// Custom Geometries\nconst TAG_GEOMETRY_POINT = 88;\nconst TAG_GEOMETRY_LINE = 89;\nconst TAG_GEOMETRY_POLYGON = 90;\nconst TAG_GEOMETRY_MULTIPOINT = 91;\nconst TAG_GEOMETRY_MULTILINE = 92;\nconst TAG_GEOMETRY_MULTIPOLYGON = 93;\nconst TAG_GEOMETRY_COLLECTION = 94;\n\nexport const replacer = {\n\tencode(v: unknown): unknown {\n\t\tif (v instanceof Date) {\n\t\t\treturn new Tagged(TAG_CUSTOM_DATETIME, dateToCborCustomDate(v));\n\t\t}\n\t\tif (v === undefined) return new Tagged(TAG_NONE, null);\n\t\tif (v instanceof Uuid) {\n\t\t\treturn new Tagged(TAG_SPEC_UUID, v.toBuffer());\n\t\t}\n\t\tif (v instanceof Decimal) {\n\t\t\treturn new Tagged(TAG_STRING_DECIMAL, v.toString());\n\t\t}\n\t\tif (v instanceof Duration) {\n\t\t\treturn new Tagged(TAG_CUSTOM_DURATION, v.toCompact());\n\t\t}\n\t\tif (v instanceof RecordId) {\n\t\t\treturn new Tagged(TAG_RECORDID, [v.tb, v.id]);\n\t\t}\n\t\tif (v instanceof StringRecordId) {\n\t\t\treturn new Tagged(TAG_RECORDID, v.rid);\n\t\t}\n\t\tif (v instanceof RecordIdRange) {\n\t\t\treturn new Tagged(TAG_RECORDID, [\n\t\t\t\tv.tb,\n\t\t\t\tnew Tagged(TAG_RANGE, rangeToCbor([v.beg, v.end])),\n\t\t\t]);\n\t\t}\n\t\tif (v instanceof Table) return new Tagged(TAG_TABLE, v.tb);\n\t\tif (v instanceof Future) return new Tagged(TAG_FUTURE, v.inner);\n\t\tif (v instanceof Range)\n\t\t\treturn new Tagged(TAG_RANGE, rangeToCbor([v.beg, v.end]));\n\t\tif (v instanceof GeometryPoint) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_POINT, v.point);\n\t\t}\n\t\tif (v instanceof GeometryLine) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_LINE, v.line);\n\t\t}\n\t\tif (v instanceof GeometryPolygon) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_POLYGON, v.polygon);\n\t\t}\n\t\tif (v instanceof GeometryMultiPoint) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_MULTIPOINT, v.points);\n\t\t}\n\t\tif (v instanceof GeometryMultiLine) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_MULTILINE, v.lines);\n\t\t}\n\t\tif (v instanceof GeometryMultiPolygon) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_MULTIPOLYGON, v.polygons);\n\t\t}\n\t\tif (v instanceof GeometryCollection) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_COLLECTION, v.collection);\n\t\t}\n\t\treturn v;\n\t},\n\tdecode(v: unknown): unknown {\n\t\tif (!(v instanceof Tagged)) return v;\n\n\t\tswitch (v.tag) {\n\t\t\tcase TAG_SPEC_DATETIME:\n\t\t\t\treturn new Date(v.value);\n\t\t\tcase TAG_SPEC_UUID:\n\t\t\tcase TAG_STRING_UUID:\n\t\t\t\treturn new Uuid(v.value);\n\t\t\tcase TAG_CUSTOM_DATETIME:\n\t\t\t\treturn cborCustomDateToDate(v.value);\n\t\t\tcase TAG_NONE:\n\t\t\t\treturn undefined;\n\t\t\tcase TAG_STRING_DECIMAL:\n\t\t\t\treturn new Decimal(v.value);\n\t\t\tcase TAG_STRING_DURATION:\n\t\t\t\treturn new Duration(v.value);\n\t\t\tcase TAG_CUSTOM_DURATION:\n\t\t\t\treturn Duration.fromCompact(v.value);\n\t\t\tcase TAG_TABLE:\n\t\t\t\treturn new Table(v.value);\n\t\t\tcase TAG_FUTURE:\n\t\t\t\treturn new Future(v.value);\n\t\t\tcase TAG_RANGE:\n\t\t\t\treturn new Range(...cborToRange(v.value));\n\t\t\tcase TAG_BOUND_INCLUDED:\n\t\t\t\treturn new BoundIncluded(v.value);\n\t\t\tcase TAG_BOUND_EXCLUDED:\n\t\t\t\treturn new BoundExcluded(v.value);\n\t\t\tcase TAG_RECORDID: {\n\t\t\t\tif (v.value[1] instanceof Range) {\n\t\t\t\t\treturn new RecordIdRange(v.value[0], v.value[1].beg, v.value[1].end);\n\t\t\t\t}\n\t\t\t\treturn new RecordId(v.value[0], v.value[1]);\n\t\t\t}\n\t\t\tcase TAG_GEOMETRY_POINT:\n\t\t\t\treturn new GeometryPoint(v.value);\n\t\t\tcase TAG_GEOMETRY_LINE:\n\t\t\t\treturn new GeometryLine(v.value);\n\t\t\tcase TAG_GEOMETRY_POLYGON:\n\t\t\t\treturn new GeometryPolygon(v.value);\n\t\t\tcase TAG_GEOMETRY_MULTIPOINT:\n\t\t\t\treturn new GeometryMultiPoint(v.value);\n\t\t\tcase TAG_GEOMETRY_MULTILINE:\n\t\t\t\treturn new GeometryMultiLine(v.value);\n\t\t\tcase TAG_GEOMETRY_MULTIPOLYGON:\n\t\t\t\treturn new GeometryMultiPolygon(v.value);\n\t\t\tcase TAG_GEOMETRY_COLLECTION:\n\t\t\t\treturn new GeometryCollection(v.value);\n\t\t}\n\t},\n};\n\nObject.freeze(replacer);\n\n/**\n * Recursively encode any supported SurrealQL value into a binary CBOR representation.\n * @param data - The input value\n * @returns CBOR binary representation\n */\nexport function encodeCbor<T>(data: T): ArrayBuffer {\n\treturn encode(data, {\n\t\treplacer: replacer.encode,\n\t});\n}\n\n/**\n * Decode a CBOR encoded SurrealQL value into object representation.\n * @param data - The encoded SurrealQL value\n * @returns The parsed SurrealQL value\n */\n// biome-ignore lint/suspicious/noExplicitAny: Don't know what it will return\nexport function decodeCbor(data: ArrayBufferLike): any {\n\treturn decode(data, {\n\t\treplacer: replacer.decode,\n\t});\n}\n", "import {\n\tEncoded,\n\ttype Fill,\n\tGap,\n\ttype PartiallyEncoded,\n\tWriter,\n\tencode,\n\tpartiallyEncodeObject,\n} from \"../cbor\";\nimport { replacer } from \"../data/cbor\";\n\nlet textEncoder: TextEncoder;\n\nexport type ConvertMethod<T = unknown> = (result: unknown[]) => T;\n\n/**\n * A query and its bindings prepared for execution, which can be passed to the .query() method.\n */\nexport class PreparedQuery {\n\tprivate _query: Uint8Array;\n\tprivate _bindings: Record<string, PartiallyEncoded>;\n\tprivate length: number;\n\n\tconstructor(query: string, bindings?: Record<string, unknown>) {\n\t\ttextEncoder ??= new TextEncoder();\n\t\tthis._query = textEncoder.encode(query);\n\t\tthis._bindings = partiallyEncodeObject(bindings ?? {}, {\n\t\t\treplacer: replacer.encode,\n\t\t});\n\t\tthis.length = Object.keys(this._bindings).length;\n\t}\n\n\t/**\n\t * Retrieves the encoded query string.\n\t */\n\tget query(): Encoded {\n\t\t// Up to 9 bytes for the prefix\n\t\tconst w = new Writer(this._query.byteLength + 9);\n\t\tw.writeMajor(3, this._query.byteLength);\n\t\tw.writeUint8Array(this._query);\n\t\treturn new Encoded(w.output(false));\n\t}\n\n\t/**\n\t * Retrieves the encoded bindings.\n\t */\n\tget bindings(): Record<string, PartiallyEncoded> {\n\t\treturn this._bindings;\n\t}\n\n\t/**\n\t * Compile this query and its bindings into a single ArrayBuffer, optionally filling gaps.\n\t * @param fills - The gap values to fill\n\t */\n\tbuild(fills?: Fill[]): ArrayBuffer {\n\t\treturn encode([this.query, this.bindings], { fills });\n\t}\n\n\t/**\n\t * A template literal tag function for appending additional query segments and bindings to the prepared query.\n\t * @param query_raw - The additional query segments to append\n\t * @param values - The additional interpolated values to append\n\t * @example\n\t * const query = surrealql`SELECT * FROM person`;\n\t *\n\t * if (filter) {\n\t *   query.append` WHERE name = ${filter}`;\n\t * }\n\t */\n\tappend(\n\t\tquery_raw: string[] | TemplateStringsArray,\n\t\t...values: unknown[]\n\t): PreparedQuery {\n\t\tconst base = this.length;\n\t\tthis.length += values.length;\n\n\t\tlet reused = 0;\n\t\tconst gaps = new Map<Gap, number>();\n\t\tconst mapped_bindings = values.map((v, i) => {\n\t\t\tif (v instanceof Gap) {\n\t\t\t\tconst index = gaps.get(v);\n\t\t\t\tif (index !== undefined) {\n\t\t\t\t\treused++;\n\t\t\t\t\treturn [`bind___${index}`, v] as const;\n\t\t\t\t}\n\n\t\t\t\tgaps.set(v, i - reused);\n\t\t\t}\n\n\t\t\treturn [`bind___${base + i - reused}`, v] as const;\n\t\t});\n\n\t\tfor (const [k, v] of mapped_bindings) {\n\t\t\tthis._bindings[k] = encode(v, {\n\t\t\t\treplacer: replacer.encode,\n\t\t\t\tpartial: true,\n\t\t\t});\n\t\t}\n\n\t\tconst query = query_raw\n\t\t\t.flatMap((segment, i) => {\n\t\t\t\tconst variable = mapped_bindings[i]?.[0];\n\t\t\t\treturn [segment, ...(variable ? [`$${variable}`] : [])];\n\t\t\t})\n\t\t\t.join(\"\");\n\n\t\ttextEncoder ??= new TextEncoder();\n\t\tconst current = new Uint8Array(this._query);\n\t\tconst added = textEncoder.encode(query);\n\t\tthis._query = new Uint8Array(current.byteLength + added.byteLength);\n\t\tthis._query.set(current);\n\t\tthis._query.set(added, current.byteLength);\n\t\treturn this;\n\t}\n}\n", "import { Gap } from \"../cbor/gap.ts\";\nimport { PreparedQuery } from \"./prepared-query.ts\";\n\n/**\n * A template literal tag function for creating prepared queries from query strings.\n * Interpolated values are automatically stored as bindings.\n * @param query_raw - The raw query string\n * @param values - The interpolated values\n * @example const query = surrealql`SELECT * FROM ${id}`;\n * @returns A PreparedQuery instance\n */\nexport function surrealql(\n\tquery_raw: string[] | TemplateStringsArray,\n\t...values: unknown[]\n): PreparedQuery {\n\tlet reused = 0;\n\tconst gaps = new Map<Gap, number>();\n\tconst mapped_bindings = values.map((v, i) => {\n\t\tif (v instanceof Gap) {\n\t\t\tconst index = gaps.get(v);\n\t\t\tif (index !== undefined) {\n\t\t\t\treused++;\n\t\t\t\treturn [`bind___${index}`, v] as const;\n\t\t\t}\n\n\t\t\tgaps.set(v, i - reused);\n\t\t}\n\n\t\treturn [`bind___${i - reused}`, v] as const;\n\t});\n\n\tconst bindings = mapped_bindings.reduce<Record<`bind___${number}`, unknown>>(\n\t\t(prev, [k, v]) => {\n\t\t\tprev[k] = v;\n\t\t\treturn prev;\n\t\t},\n\t\t{},\n\t);\n\n\tconst query = query_raw\n\t\t.flatMap((segment, i) => {\n\t\t\tconst variable = mapped_bindings[i]?.[0];\n\t\t\treturn [segment, ...(variable ? [`$${variable}`] : [])];\n\t\t})\n\t\t.join(\"\");\n\n\treturn new PreparedQuery(query, bindings);\n}\n\nexport { surrealql as surql };\n", "import type { AuthController } from \"./auth\";\nimport type { Fill } from \"./cbor\";\nimport { type RecordId, Uuid } from \"./data\";\nimport { SurrealDbError } from \"./errors\";\nimport type { Surreal } from \"./surreal\";\nimport type { PreparedQuery } from \"./util/prepared-query\";\n\nexport type ActionResult<T extends Record<string, unknown>> = Prettify<\n\tT[\"id\"] extends RecordId ? T : { id: RecordId } & T\n>;\n\nexport type Prettify<T> = {\n\t[K in keyof T]: T[K];\n} & {}; // deno-lint-ignore ban-types\n\nexport type QueryParameters =\n\t| [query: string, bindings?: Record<string, unknown>]\n\t| [prepared: PreparedQuery, gaps?: Fill[]];\n\n//////////////////////////////////////////////\n//////////   AUTHENTICATION TYPES   //////////\n//////////////////////////////////////////////\n\nexport function convertAuth(params: AnyAuth): Record<string, unknown> {\n\tlet result: Record<string, unknown> = {};\n\tconst convertString = (a: string, b: string, optional?: boolean) => {\n\t\tif (a in params) {\n\t\t\tresult[b] = `${params[a as keyof AnyAuth]}`;\n\t\t\tdelete result[a];\n\t\t} else if (optional !== true) {\n\t\t\tthrow new SurrealDbError(\n\t\t\t\t`Key ${a} is missing from the authentication parameters`,\n\t\t\t);\n\t\t}\n\t};\n\n\tif (\"scope\" in params) {\n\t\tresult = { ...params };\n\t\tconvertString(\"scope\", \"sc\");\n\t\tconvertString(\"namespace\", \"ns\");\n\t\tconvertString(\"database\", \"db\");\n\t} else if (\"variables\" in params) {\n\t\tresult = { ...params.variables };\n\t\tconvertString(\"access\", \"ac\");\n\t\tconvertString(\"namespace\", \"ns\");\n\t\tconvertString(\"database\", \"db\");\n\t} else {\n\t\tconvertString(\"access\", \"ac\", true);\n\t\tconvertString(\"database\", \"db\", true);\n\t\tconvertString(\"namespace\", \"ns\", !(\"database\" in params));\n\t\tconvertString(\"username\", \"user\");\n\t\tconvertString(\"password\", \"pass\");\n\t}\n\n\treturn result;\n}\n\nexport type RootAuth = {\n\tusername: string;\n\tpassword: string;\n};\n\nexport type NamespaceAuth = {\n\tnamespace: string;\n\tusername: string;\n\tpassword: string;\n};\n\nexport type DatabaseAuth = {\n\tnamespace: string;\n\tdatabase: string;\n\tusername: string;\n\tpassword: string;\n};\n\nexport type AccessSystemAuth = Prettify<\n\t(RootAuth | NamespaceAuth | DatabaseAuth) & {\n\t\taccess: string;\n\t\tvariables?: never;\n\t}\n>;\n\nexport type ScopeAuth = {\n\tnamespace?: string;\n\tdatabase?: string;\n\tscope: string;\n\t[K: string]: unknown;\n};\n\nexport type AccessRecordAuth = {\n\tnamespace?: string;\n\tdatabase?: string;\n\taccess: string;\n\tvariables: {\n\t\tns?: never;\n\t\tdb?: never;\n\t\tac?: never;\n\t\t[K: string]: unknown;\n\t};\n};\n\nexport type AnyAuth =\n\t| RootAuth\n\t| NamespaceAuth\n\t| DatabaseAuth\n\t| ScopeAuth\n\t| AccessSystemAuth\n\t| AccessRecordAuth;\n\nexport type Token = string;\n\nexport type AuthClient = Pick<\n\tSurreal,\n\t\"signin\" | \"signup\" | \"authenticate\" | \"invalidate\"\n>;\n\n/////////////////////////////////////\n//////////   QUERY TYPES   //////////\n/////////////////////////////////////\n\nexport type QueryResult<T = unknown> = QueryResultOk<T> | QueryResultErr;\nexport type QueryResultOk<T> = {\n\tstatus: \"OK\";\n\ttime: string;\n\tresult: T;\n};\n\nexport type QueryResultErr = {\n\tstatus: \"ERR\";\n\ttime: string;\n\tresult: string;\n};\n\nexport type MapQueryResult<T> = {\n\t[K in keyof T]: QueryResult<T[K]>;\n};\n\n/////////////////////////////////////\n//////////   PATCH TYPES   //////////\n/////////////////////////////////////\n\ntype BasePatch<T = string> = {\n\tpath: T;\n};\n\nexport type AddPatch<T = string, U = unknown> = BasePatch<T> & {\n\top: \"add\";\n\tvalue: U;\n};\n\nexport type RemovePatch<T = string> = BasePatch<T> & {\n\top: \"remove\";\n};\n\nexport type ReplacePatch<T = string, U = unknown> = BasePatch<T> & {\n\top: \"replace\";\n\tvalue: U;\n};\n\nexport type ChangePatch<T = string, U = string> = BasePatch<T> & {\n\top: \"change\";\n\tvalue: U;\n};\n\nexport type CopyPatch<T = string, U = string> = BasePatch<T> & {\n\top: \"copy\";\n\tfrom: U;\n};\n\nexport type MovePatch<T = string, U = string> = BasePatch<T> & {\n\top: \"move\";\n\tfrom: U;\n};\n\nexport type TestPatch<T = string, U = unknown> = BasePatch<T> & {\n\top: \"test\";\n\tvalue: U;\n};\n\nexport type Patch =\n\t| AddPatch\n\t| RemovePatch\n\t| ReplacePatch\n\t| ChangePatch\n\t| CopyPatch\n\t| MovePatch\n\t| TestPatch;\n\n// RPC\n\nexport type RpcRequest<\n\tMethod extends string = string,\n\tParams extends unknown[] | undefined = unknown[],\n> = {\n\tmethod: Method;\n\tparams?: Params;\n};\n\nexport type RpcResponse<Result = unknown> =\n\t| RpcResponseOk<Result>\n\t| RpcResponseErr;\n\nexport type RpcResponseOk<Result = unknown> = {\n\tresult: Result;\n\terror?: never;\n};\n\nexport type RpcResponseErr = {\n\tresult?: never;\n\terror: {\n\t\tcode: number;\n\t\tmessage: string;\n\t};\n};\n\n// Live\n\nexport const liveActions = [\"CREATE\", \"UPDATE\", \"DELETE\"] as const;\nexport type LiveAction = (typeof liveActions)[number];\nexport type LiveResult = {\n\tid: Uuid;\n\taction: LiveAction;\n\tresult: Record<string, unknown>;\n};\n\nexport type LiveHandlerArguments<\n\tResult extends Record<string, unknown> | Patch = Record<string, unknown>,\n> =\n\t| [action: LiveAction, result: Result]\n\t| [action: \"CLOSE\", result: \"killed\" | \"disconnected\"];\n\nexport type LiveHandler<\n\tResult extends Record<string, unknown> | Patch = Record<string, unknown>,\n> = (...[action, result]: LiveHandlerArguments<Result>) => unknown;\n\nexport function isLiveResult(v: unknown): v is LiveResult {\n\tif (typeof v !== \"object\") return false;\n\tif (v === null) return false;\n\tif (!(\"id\" in v && \"action\" in v && \"result\" in v)) return false;\n\n\tif (!(v.id instanceof Uuid)) return false;\n\tif (!liveActions.includes(v.action as LiveAction)) return false;\n\tif (typeof v.result !== \"object\") return false;\n\tif (v.result === null) return false;\n\n\treturn true;\n}\n\n/////////////////////////////////////\n/////////   EXPORT TYPES   //////////\n/////////////////////////////////////\n\nexport type ExportOptions = {\n\tusers: boolean;\n\taccesses: boolean;\n\tparams: boolean;\n\tfunctions: boolean;\n\tanalyzers: boolean;\n\tversions: boolean;\n\ttables: boolean | string[];\n\trecords: boolean;\n};\n\n/////////////////////////////////////\n////////   CONNECT OPTIONS   ////////\n/////////////////////////////////////\n\nexport const DEFAULT_RECONNECT_OPTIONS: ReconnectOptions = {\n\tenabled: true,\n\tattempts: 5,\n\tretryDelay: 1000,\n\tretryDelayMax: 60000,\n\tretryDelayMultiplier: 2,\n\tretryDelayJitter: 0.1,\n};\n\nexport type PrepareFn = (auth: AuthController) => unknown;\n\nexport interface ConnectOptions {\n\t/** The namespace to connect to */\n\tnamespace?: string;\n\t/** The database to connect to */\n\tdatabase?: string;\n\t/** Authentication details to use */\n\tauth?: AnyAuth | Token;\n\t/** A callback to customise the connection before connection completion */\n\tprepare?: PrepareFn;\n\t/** Enable automated SurrealDB version checking */\n\tversionCheck?: boolean;\n\t/** The maximum amount of time in milliseconds to wait for version checking */\n\tversionCheckTimeout?: number;\n\t/** Configure reconnect behavior */\n\treconnect?: boolean | Partial<ReconnectOptions>;\n}\n\nexport interface ReconnectOptions {\n\t/** Reconnect after a connection has unexpectedly dropped */\n\tenabled: boolean;\n\t/** How many attempts will be made at reconnecting, -1 for unlimited */\n\tattempts: number;\n\t/** The minimum amount of time in milliseconds to wait before reconnecting */\n\tretryDelay: number;\n\t/** The maximum amount of time in milliseconds to wait before reconnecting */\n\tretryDelayMax: number;\n\t/** The amount to multiply the delay by after each failed attempt */\n\tretryDelayMultiplier: number;\n\t/** A float percentage to randomly offset each delay by  */\n\tretryDelayJitter: number;\n}\n", "import {\n\tDecimal,\n\tDuration,\n\tFuture,\n\tGeometry,\n\tRange,\n\tRecordId,\n\tRecordIdRange,\n\tStringRecordId,\n\tTable,\n\tUuid,\n} from \"../data\";\n\nexport type Jsonify<T> = T extends\n\t| Date\n\t| Uuid\n\t| Decimal\n\t| Duration\n\t| Future\n\t| Range<unknown, unknown>\n\t| StringRecordId\n\t? string\n\t: T extends undefined\n\t\t? never\n\t\t: T extends Record<string | number | symbol, unknown> | Array<unknown>\n\t\t\t? { [K in keyof T]: Jsonify<T[K]> }\n\t\t\t: T extends Map<infer K, infer V>\n\t\t\t\t? Map<K, Jsonify<V>>\n\t\t\t\t: T extends Set<infer V>\n\t\t\t\t\t? Set<Jsonify<V>>\n\t\t\t\t\t: T extends Geometry\n\t\t\t\t\t\t? ReturnType<T[\"toJSON\"]>\n\t\t\t\t\t\t: T extends RecordId<infer Tb>\n\t\t\t\t\t\t\t? `${Tb}:${string}`\n\t\t\t\t\t\t\t: T extends RecordIdRange<infer Tb>\n\t\t\t\t\t\t\t\t? `${Tb}:${string}..${string}`\n\t\t\t\t\t\t\t\t: T extends Table<infer Tb>\n\t\t\t\t\t\t\t\t\t? `${Tb}`\n\t\t\t\t\t\t\t\t\t: T;\n/**\n * Recursively convert any supported SurrealQL value into a serializable JSON representation.\n * @param input - The input value\n * @returns JSON-safe representation\n */\nexport function jsonify<T>(input: T): Jsonify<T> {\n\tif (typeof input === \"object\") {\n\t\tif (input === null) return null as Jsonify<T>;\n\n\t\t// We only want to process \"SurrealQL values\"\n\t\tif (\n\t\t\tinput instanceof Date ||\n\t\t\tinput instanceof Uuid ||\n\t\t\tinput instanceof Decimal ||\n\t\t\tinput instanceof Duration ||\n\t\t\tinput instanceof Future ||\n\t\t\tinput instanceof Range ||\n\t\t\tinput instanceof StringRecordId ||\n\t\t\tinput instanceof RecordIdRange ||\n\t\t\tinput instanceof RecordId ||\n\t\t\tinput instanceof Geometry ||\n\t\t\tinput instanceof Table\n\t\t) {\n\t\t\treturn input.toJSON() as Jsonify<T>;\n\t\t}\n\n\t\t// We check by prototype, because we do not want to process derivatives of objects and arrays\n\t\tswitch (Object.getPrototypeOf(input)) {\n\t\t\tcase Object.prototype: {\n\t\t\t\tconst entries = Object.entries(input as object);\n\t\t\t\tconst mapped = entries\n\t\t\t\t\t.map(([k, v]) => [k, jsonify(v)])\n\t\t\t\t\t.filter(([_, v]) => v !== undefined);\n\t\t\t\treturn Object.fromEntries(mapped) as Jsonify<T>;\n\t\t\t}\n\t\t\tcase Map.prototype: {\n\t\t\t\tconst entries = Array.from(input as [string, unknown][]);\n\t\t\t\tconst mapped = entries\n\t\t\t\t\t.map(([k, v]) => [k, jsonify(v)])\n\t\t\t\t\t.filter(([_, v]) => v !== undefined);\n\t\t\t\treturn new Map(mapped as [string, unknown][]) as Jsonify<T>;\n\t\t\t}\n\t\t\tcase Array.prototype:\n\t\t\t\treturn (input as []).map(jsonify) as Jsonify<T>;\n\t\t\tcase Set.prototype:\n\t\t\t\treturn new Set([...(input as [])].map(jsonify)) as Jsonify<T>;\n\t\t}\n\t}\n\n\treturn input as Jsonify<T>;\n}\n", "import { UnsupportedVersion, VersionRetrievalFailure } from \"../errors.ts\";\n\ntype Version = `${number}.${number}.${number}`;\nexport const defaultVersionCheckTimeout = 5000;\nexport const supportedSurrealDbVersionMin: Version = \"1.4.2\";\nexport const supportedSurrealDbVersionUntil: Version = \"3.0.0\";\nexport const supportedSurrealDbVersionRange: string = `>= ${supportedSurrealDbVersionMin} < ${supportedSurrealDbVersionUntil}`;\n\nexport function versionCheck(\n\tversion: string,\n\tmin: Version = supportedSurrealDbVersionMin,\n\tuntil: Version = supportedSurrealDbVersionUntil,\n): true {\n\tif (!isVersionSupported(version, min, until)) {\n\t\tthrow new UnsupportedVersion(version, `>= ${min} < ${until}`);\n\t}\n\n\treturn true;\n}\n\nexport function isVersionSupported(\n\tversion: string,\n\tmin: Version = supportedSurrealDbVersionMin,\n\tuntil: Version = supportedSurrealDbVersionUntil,\n): boolean {\n\treturn (\n\t\tmin.localeCompare(version, undefined, {\n\t\t\tnumeric: true,\n\t\t}) <= 0 &&\n\t\tuntil.localeCompare(version, undefined, {\n\t\t\tnumeric: true,\n\t\t}) === 1\n\t);\n}\n\n/**\n * Query the version of a remote SurrealDB instance\n * @param url - The URL of the remote SurrealDB instance\n * @param timeout - The timeout in milliseconds for the request\n * @returns\n */\nexport async function retrieveRemoteVersion(\n\turl: URL,\n\ttimeout?: number,\n): Promise<Version> {\n\tconst mappedProtocols = {\n\t\t\"ws:\": \"http:\",\n\t\t\"wss:\": \"https:\",\n\t\t\"http:\": \"http:\",\n\t\t\"https:\": \"https:\",\n\t} as Record<string, string>;\n\n\tconst protocol = mappedProtocols[url.protocol];\n\tif (protocol) {\n\t\tconst basepath = url.pathname.slice(0, -4);\n\t\t// biome-ignore lint/style/noParameterAssign: need to clone URL instance to prevent altering the original\n\t\turl = new URL(url);\n\t\turl.pathname = `${basepath}/version`;\n\t\turl.protocol = protocol;\n\n\t\tconst controller = new AbortController();\n\t\tconst id = setTimeout(\n\t\t\t() => controller.abort(),\n\t\t\ttimeout ?? defaultVersionCheckTimeout,\n\t\t);\n\t\tconst versionPrefix = \"surrealdb-\";\n\t\tconst version = await fetch(url, {\n\t\t\tsignal: controller.signal,\n\t\t})\n\t\t\t.then((res) => res.text())\n\t\t\t.then((version) => version.slice(versionPrefix.length))\n\t\t\t.catch((e) => {\n\t\t\t\tthrow new VersionRetrievalFailure(e);\n\t\t\t})\n\t\t\t.finally(() => {\n\t\t\t\tclearTimeout(id);\n\t\t\t});\n\n\t\treturn version as Version;\n\t}\n\n\tthrow new VersionRetrievalFailure();\n}\n", "let id = 0;\nexport function getIncrementalID(): string {\n\tid = (id + 1) % Number.MAX_SAFE_INTEGER;\n\treturn id.toString();\n}\n", "import { StringRecordId, Uuid } from \"../data\";\n\n/**\n * A template literal tag function for parsing a string type\n * @param string - The string to parse\n * @param values - The interpolated values\n * @returns The parsed string\n */\nexport function s(\n\tstring: string[] | TemplateStringsArray,\n\t...values: unknown[]\n): string {\n\treturn string.reduce(\n\t\t(prev, curr, i) => `${prev}${curr}${values[i] ?? \"\"}`,\n\t\t\"\",\n\t);\n}\n\n/**\n * A template literal tag function for parsing a string into a Date\n * @param string - The string to parse\n * @param values - The interpolated values\n * @returns The parsed Date\n */\nexport function d(\n\tstring: string[] | TemplateStringsArray,\n\t...values: unknown[]\n): Date {\n\treturn new Date(s(string, values));\n}\n\n/**\n * A template literal tag function for parsing a string into a StringRecordId\n * @param string - The string to parse\n * @param values - The interpolated values\n * @returns The parsed StringRecordId\n */\nexport function r(\n\tstring: string[] | TemplateStringsArray,\n\t...values: unknown[]\n): StringRecordId {\n\treturn new StringRecordId(s(string, values));\n}\n\n/**\n * A template literal tag function for parsing a string into a Uuid\n * @param string - The string to parse\n * @param values - The interpolated values\n * @returns The parsed Uuid\n */\nexport function u(\n\tstring: string[] | TemplateStringsArray,\n\t...values: unknown[]\n): Uuid {\n\treturn new Uuid(s(string, values));\n}\n", "import type { EngineDisconnected } from \"../errors\";\nimport type {\n\tExportOptions,\n\tLiveHandlerArguments,\n\tPrepareFn,\n\tRpcRequest,\n\tRpcResponse,\n} from \"../types\";\nimport type { Emitter } from \"../util/emitter\";\nimport type { ReconnectContext } from \"../util/reconnect\";\n\nexport type Engine = new (context: EngineContext) => AbstractEngine;\nexport type Engines = Record<string, Engine>;\nexport const RetryMessage: unique symbol = Symbol(\"RetryMessage\");\n\nexport type EngineEvents = {\n\tconnecting: [];\n\tconnected: [];\n\treconnecting: [];\n\tdisconnected: [];\n\terror: [Error];\n\n\t[K: `rpc-${string | number}`]: [\n\t\tRpcResponse | EngineDisconnected | typeof RetryMessage,\n\t];\n\t[K: `live-${string}`]: LiveHandlerArguments;\n};\n\nexport enum ConnectionStatus {\n\tDisconnected = \"disconnected\",\n\tConnecting = \"connecting\",\n\tReconnecting = \"reconnecting\",\n\tConnected = \"connected\",\n\tError = \"error\",\n}\n\nexport class EngineContext {\n\treadonly emitter: Emitter<EngineEvents>;\n\treadonly encodeCbor: (value: unknown) => ArrayBuffer;\n\t// biome-ignore lint/suspicious/noExplicitAny: Don't know what it will return\n\treadonly decodeCbor: (value: ArrayBufferLike) => any;\n\treadonly reconnect: ReconnectContext;\n\treadonly prepare: PrepareFn | undefined;\n\n\tconstructor({\n\t\temitter,\n\t\tencodeCbor,\n\t\tdecodeCbor,\n\t\treconnect,\n\t\tprepare,\n\t}: {\n\t\temitter: Emitter<EngineEvents>;\n\t\tencodeCbor: (value: unknown) => ArrayBuffer;\n\t\t// biome-ignore lint/suspicious/noExplicitAny: Don't know what it will return\n\t\tdecodeCbor: (value: ArrayBufferLike) => any;\n\t\treconnect: ReconnectContext;\n\t\tprepare: PrepareFn | undefined;\n\t}) {\n\t\tthis.emitter = emitter;\n\t\tthis.encodeCbor = encodeCbor;\n\t\tthis.decodeCbor = decodeCbor;\n\t\tthis.reconnect = reconnect;\n\t\tthis.prepare = prepare;\n\t}\n}\n\nexport abstract class AbstractEngine {\n\treadonly context: EngineContext;\n\tready: Promise<void> | undefined;\n\tstatus: ConnectionStatus = ConnectionStatus.Disconnected;\n\tconnection: {\n\t\turl: URL | undefined;\n\t\tnamespace: string | undefined;\n\t\tdatabase: string | undefined;\n\t\ttoken: string | undefined;\n\t} = {\n\t\turl: undefined,\n\t\tnamespace: undefined,\n\t\tdatabase: undefined,\n\t\ttoken: undefined,\n\t};\n\n\tconstructor(context: EngineContext) {\n\t\tthis.context = context;\n\t}\n\n\tget emitter(): EngineContext[\"emitter\"] {\n\t\treturn this.context.emitter;\n\t}\n\n\tget encodeCbor(): EngineContext[\"encodeCbor\"] {\n\t\treturn this.context.encodeCbor;\n\t}\n\n\tget decodeCbor(): EngineContext[\"decodeCbor\"] {\n\t\treturn this.context.decodeCbor;\n\t}\n\n\tabstract connect(url: URL): Promise<void>;\n\tabstract disconnect(): Promise<void>;\n\tabstract rpc<\n\t\tMethod extends string,\n\t\tParams extends unknown[] | undefined,\n\t\tResult,\n\t>(\n\t\trequest: RpcRequest<Method, Params>,\n\t\tforce?: boolean,\n\t): Promise<RpcResponse<Result>>;\n\n\tabstract version(url: URL, timeout?: number): Promise<string>;\n\tabstract export(options?: Partial<ExportOptions>): Promise<string>;\n\tabstract import(data: string): Promise<void>;\n\n\t// protected authClient(): AuthClient {\n\t// \tconst self = this;\n\n\t// \treturn {\n\t// \t\tasync signup(vars: ScopeAuth | AccessRecordAuth): Promise<Token> {\n\t// \t\t\tconst parsed = processAuthVars(vars, self.connection);\n\t// \t\t\tconst converted = convertAuth(parsed);\n\t// \t\t\tconst res: RpcResponse<Token> = await self.rpc({\n\t// \t\t\t\tmethod: \"signup\",\n\t// \t\t\t\tparams: [converted],\n\t// \t\t\t});\n\n\t// \t\t\tif (res.error) throw new ResponseError(res.error.message);\n\t// \t\t\tif (!res.result) {\n\t// \t\t\t\tthrow new NoTokenReturned();\n\t// \t\t\t}\n\n\t// \t\t\treturn res.result;\n\t// \t\t}\n\n\t// \t\tasync signin(vars: AnyAuth): Promise<Token> {\n\t// \t\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t// \t\t\tconst parsed = processAuthVars(vars, this.connection.connection);\n\t// \t\t\tconst converted = convertAuth(parsed);\n\t// \t\t\tconst res = await this.rpc<Token>(\"signin\", [converted]);\n\n\t// \t\t\tif (res.error) throw new ResponseError(res.error.message);\n\t// \t\t\tif (!res.result) {\n\t// \t\t\t\tthrow new NoTokenReturned();\n\t// \t\t\t}\n\n\t// \t\t\treturn res.result;\n\t// \t\t}\n\n\t// \t\tasync authenticate(token: Token): Promise<true> {\n\t// \t\t\tconst res = await this.rpc<string>(\"authenticate\", [token]);\n\t// \t\t\tif (res.error) throw new ResponseError(res.error.message);\n\t// \t\t\treturn true;\n\t// \t\t}\n\n\t// \t\tasync invalidate(): Promise<true> {\n\t// \t\t\tconst res = await this.rpc(\"invalidate\");\n\t// \t\t\tif (res.error) throw new ResponseError(res.error.message);\n\t// \t\t\treturn true;\n\t// \t\t}\n\t// \t}\n\t// }\n}\n", "import { NoDatabaseSpecified, NoNamespaceSpecified } from \"../errors.ts\";\nimport type { AnyAuth } from \"../types.ts\";\n\nexport function processAuthVars<T extends AnyAuth>(\n\tvars: T,\n\tfallback?: {\n\t\tnamespace?: string;\n\t\tdatabase?: string;\n\t},\n): AnyAuth {\n\tif (\n\t\t\"scope\" in vars ||\n\t\t(\"access\" in vars && \"variables\" in vars && vars.variables)\n\t) {\n\t\tif (!vars.namespace) {\n\t\t\tif (!fallback?.namespace) throw new NoNamespaceSpecified();\n\t\t\tvars.namespace = fallback.namespace;\n\t\t}\n\n\t\tif (!vars.database) {\n\t\t\tif (!fallback?.database) throw new NoDatabaseSpecified();\n\t\t\tvars.database = fallback.database;\n\t\t}\n\t}\n\n\treturn vars;\n}\n", "import type { AbstractEngine } from \"./engines/abstract\";\nimport { NoActiveSocket, NoTokenReturned, ResponseError } from \"./errors\";\nimport {\n\ttype AccessRecordAuth,\n\ttype AnyAuth,\n\ttype RpcResponse,\n\ttype ScopeAuth,\n\ttype Token,\n\tconvertAuth,\n} from \"./types\";\nimport { processAuthVars } from \"./util/process-auth-vars\";\n\nexport abstract class AuthController {\n\tabstract connection: AbstractEngine | undefined;\n\n\tabstract rpc<Result>(\n\t\tmethod: string,\n\t\tparams?: unknown[],\n\t): Promise<RpcResponse<Result>>;\n\n\t/**\n\t * Signs up to a specific authentication scope.\n\t * @param vars - Variables used in a signup query.\n\t * @return The authentication token.\n\t */\n\tasync signup(vars: ScopeAuth | AccessRecordAuth): Promise<Token> {\n\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t\tconst parsed = processAuthVars(vars, this.connection.connection);\n\t\tconst converted = convertAuth(parsed);\n\t\tconst res = await this.rpc<Token>(\"signup\", [converted]);\n\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\tif (!res.result) {\n\t\t\tthrow new NoTokenReturned();\n\t\t}\n\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Signs in to a specific authentication scope.\n\t * @param vars - Variables used in a signin query.\n\t * @return The authentication token.\n\t */\n\tasync signin(vars: AnyAuth): Promise<Token> {\n\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t\tconst parsed = processAuthVars(vars, this.connection.connection);\n\t\tconst converted = convertAuth(parsed);\n\t\tconst res = await this.rpc<Token>(\"signin\", [converted]);\n\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\tif (!res.result) {\n\t\t\tthrow new NoTokenReturned();\n\t\t}\n\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Authenticates the current connection with a JWT token.\n\t * @param token - The JWT authentication token.\n\t */\n\tasync authenticate(token: Token): Promise<true> {\n\t\tconst res = await this.rpc<string>(\"authenticate\", [token]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Invalidates the authentication for the current connection.\n\t */\n\tasync invalidate(): Promise<true> {\n\t\tconst res = await this.rpc(\"invalidate\");\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn true;\n\t}\n}\n\nexport class EngineAuth extends AuthController {\n\tconstructor(public connection: AbstractEngine) {\n\t\tsuper();\n\t}\n\n\trpc<Result>(\n\t\tmethod: string,\n\t\tparams?: unknown[],\n\t): Promise<RpcResponse<Result>> {\n\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t\treturn this.connection.rpc<typeof method, typeof params, Result>(\n\t\t\t{\n\t\t\t\tmethod,\n\t\t\t\tparams,\n\t\t\t},\n\t\t\ttrue,\n\t\t);\n\t}\n}\n", "import { HttpConnectionError } from \"../errors\";\nimport { AbstractEngine } from \"./abstract\";\n\nexport abstract class AbstractRemoteEngine extends AbstractEngine {\n\tprotected async req_post(\n\t\tbody: unknown,\n\t\turl?: URL,\n\t\theaders_?: Record<string, string>,\n\t): Promise<ArrayBuffer> {\n\t\tconst headers: Record<string, string> = {\n\t\t\t\"Content-Type\": \"application/cbor\",\n\t\t\tAccept: \"application/cbor\",\n\t\t\t...headers_,\n\t\t};\n\n\t\tif (this.connection.namespace) {\n\t\t\theaders[\"Surreal-NS\"] = this.connection.namespace;\n\t\t}\n\n\t\tif (this.connection.database) {\n\t\t\theaders[\"Surreal-DB\"] = this.connection.database;\n\t\t}\n\n\t\tif (this.connection.token) {\n\t\t\theaders.Authorization = `Bearer ${this.connection.token}`;\n\t\t}\n\n\t\tconst raw = await fetch(`${url ?? this.connection.url}`, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders,\n\t\t\tbody: this.encodeCbor(body),\n\t\t});\n\n\t\tconst buffer = await raw.arrayBuffer();\n\n\t\tif (raw.status === 200) {\n\t\t\treturn buffer;\n\t\t}\n\n\t\tconst dec = new TextDecoder(\"utf-8\");\n\t\tthrow new HttpConnectionError(\n\t\t\tdec.decode(buffer),\n\t\t\traw.status,\n\t\t\traw.statusText,\n\t\t\tbuffer,\n\t\t);\n\t}\n}\n", "import { EngineAuth } from \"../auth\";\nimport { ConnectionUnavailable, MissingNamespaceDatabase } from \"../errors\";\nimport type { ExportOptions, RpcRequest, RpcResponse } from \"../types\";\nimport { getIncrementalID } from \"../util/get-incremental-id\";\nimport { retrieveRemoteVersion } from \"../util/version-check\";\nimport { ConnectionStatus, type EngineEvents } from \"./abstract\";\nimport { AbstractRemoteEngine } from \"./abstract-remote\";\n\nconst ALWAYS_ALLOW = new Set([\n\t\"signin\",\n\t\"signup\",\n\t\"authenticate\",\n\t\"invalidate\",\n\t\"version\",\n\t\"use\",\n\t\"let\",\n\t\"unset\",\n\t\"query\",\n]);\n\nexport class HttpEngine extends AbstractRemoteEngine {\n\tconnection: {\n\t\turl: URL | undefined;\n\t\tnamespace: string | undefined;\n\t\tdatabase: string | undefined;\n\t\ttoken: string | undefined;\n\t\tvariables: Record<string, unknown>;\n\t} = {\n\t\turl: undefined,\n\t\tnamespace: undefined,\n\t\tdatabase: undefined,\n\t\ttoken: undefined,\n\t\tvariables: {},\n\t};\n\n\tprivate setStatus<T extends ConnectionStatus>(\n\t\tstatus: T,\n\t\t...args: EngineEvents[T]\n\t) {\n\t\tthis.status = status;\n\t\tthis.emitter.emit(status, args);\n\t}\n\n\tversion(url: URL, timeout?: number): Promise<string> {\n\t\treturn retrieveRemoteVersion(url, timeout);\n\t}\n\n\tasync connect(url: URL): Promise<void> {\n\t\tthis.setStatus(ConnectionStatus.Connecting);\n\t\tthis.connection.url = url;\n\t\tawait this.context.prepare?.(new EngineAuth(this));\n\t\tthis.setStatus(ConnectionStatus.Connected);\n\t\tthis.ready = new Promise<void>((r) => r());\n\t\treturn this.ready;\n\t}\n\n\tdisconnect(): Promise<void> {\n\t\tthis.connection = {\n\t\t\turl: undefined,\n\t\t\tnamespace: undefined,\n\t\t\tdatabase: undefined,\n\t\t\ttoken: undefined,\n\t\t\tvariables: {},\n\t\t};\n\n\t\tthis.ready = undefined;\n\t\tthis.setStatus(ConnectionStatus.Disconnected);\n\t\treturn new Promise<void>((r) => r());\n\t}\n\n\tasync rpc<\n\t\tMethod extends string,\n\t\tParams extends unknown[] | undefined,\n\t\tResult,\n\t>(\n\t\trequest: RpcRequest<Method, Params>,\n\t\tforce?: boolean,\n\t): Promise<RpcResponse<Result>> {\n\t\tif (!force) await this.ready;\n\t\tif (!this.connection.url) throw new ConnectionUnavailable();\n\n\t\tif (\n\t\t\t(!this.connection.namespace || !this.connection.database) &&\n\t\t\t!ALWAYS_ALLOW.has(request.method)\n\t\t) {\n\t\t\tthrow new MissingNamespaceDatabase();\n\t\t}\n\n\t\tif (request.method === \"use\") {\n\t\t\tconst [ns, db] = request.params as [\n\t\t\t\tstring | null | undefined,\n\t\t\t\tstring | null | undefined,\n\t\t\t];\n\n\t\t\tif (ns === null) this.connection.namespace = undefined;\n\t\t\tif (db === null) this.connection.database = undefined;\n\t\t\tif (ns) this.connection.namespace = ns;\n\t\t\tif (db) this.connection.database = db;\n\t\t\treturn {\n\t\t\t\tresult: true as Result,\n\t\t\t};\n\t\t}\n\n\t\tif (request.method === \"let\") {\n\t\t\tconst [key, value] = request.params as [string, unknown];\n\t\t\tthis.connection.variables[key] = value;\n\t\t\treturn {\n\t\t\t\tresult: true as Result,\n\t\t\t};\n\t\t}\n\n\t\tif (request.method === \"unset\") {\n\t\t\tconst [key] = request.params as [string];\n\t\t\tdelete this.connection.variables[key];\n\t\t\treturn {\n\t\t\t\tresult: true as Result,\n\t\t\t};\n\t\t}\n\n\t\tif (request.method === \"query\") {\n\t\t\trequest.params = [\n\t\t\t\trequest.params?.[0],\n\t\t\t\t{\n\t\t\t\t\t...this.connection.variables,\n\t\t\t\t\t...(request.params?.[1] ?? {}),\n\t\t\t\t},\n\t\t\t] as Params;\n\t\t}\n\n\t\tconst id = getIncrementalID();\n\t\tconst buffer = await this.req_post({ id, ...request });\n\t\tconst response: RpcResponse = this.decodeCbor(buffer);\n\n\t\tif (\"result\" in response) {\n\t\t\tswitch (request.method) {\n\t\t\t\tcase \"signin\":\n\t\t\t\tcase \"signup\": {\n\t\t\t\t\tthis.connection.token = response.result as string;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"authenticate\": {\n\t\t\t\t\tconst [token] = request.params as [string];\n\t\t\t\t\tthis.connection.token = token;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"invalidate\": {\n\t\t\t\t\tthis.connection.token = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.emitter.emit(`rpc-${id}`, [response]);\n\t\treturn response as RpcResponse<Result>;\n\t}\n\n\tget connected(): boolean {\n\t\treturn !!this.connection.url;\n\t}\n\n\tasync export(options?: Partial<ExportOptions>): Promise<string> {\n\t\tif (!this.connection.url) {\n\t\t\tthrow new ConnectionUnavailable();\n\t\t}\n\t\tconst url = new URL(this.connection.url);\n\t\tconst basepath = url.pathname.slice(0, -4);\n\t\turl.pathname = `${basepath}/export`;\n\n\t\tconst buffer = await this.req_post(options ?? {}, url, {\n\t\t\tAccept: \"plain/text\",\n\t\t});\n\n\t\tconst dec = new TextDecoder(\"utf-8\");\n\t\treturn dec.decode(buffer);\n\t}\n\n\tasync import(data: string): Promise<void> {\n\t\tif (!this.connection.url) {\n\t\t\tthrow new ConnectionUnavailable();\n\t\t}\n\t\tconst url = new URL(this.connection.url);\n\t\tconst basepath = url.pathname.slice(0, -4);\n\t\turl.pathname = `${basepath}/import`;\n\n\t\tawait this.req_post(data, url, {\n\t\t\tAccept: \"application/json\",\n\t\t});\n\t}\n}\n", "import { WebSocket } from \"isows\";\nimport { EngineAuth } from \"../auth\";\nimport {\n\tConnectionUnavailable,\n\tEngineDisconnected,\n\tNoURLProvided,\n\tReconnectFailed,\n\tResponseError,\n\tUnexpectedConnectionError,\n\tUnexpectedServerResponse,\n} from \"../errors\";\nimport {\n\ttype ExportOptions,\n\ttype RpcRequest,\n\ttype RpcResponse,\n\tisLiveResult,\n} from \"../types\";\nimport { type Completable, newCompletable } from \"../util/completable\";\nimport { getIncrementalID } from \"../util/get-incremental-id\";\nimport { retrieveRemoteVersion } from \"../util/version-check\";\nimport {\n\tConnectionStatus,\n\ttype EngineContext,\n\ttype EngineEvents,\n\tRetryMessage,\n} from \"./abstract\";\nimport { AbstractRemoteEngine } from \"./abstract-remote\";\n\nexport class WebsocketEngine extends AbstractRemoteEngine {\n\tprivate pinger?: Pinger;\n\tprivate socket?: WebSocket;\n\tprivate disconnected: Completable;\n\n\tconstructor(ctx: EngineContext) {\n\t\tsuper(ctx);\n\t\tthis.disconnected = newCompletable();\n\t}\n\n\tprivate setStatus<T extends ConnectionStatus>(\n\t\tstatus: T,\n\t\t...args: EngineEvents[T]\n\t) {\n\t\tif (\n\t\t\t(this.connection.url && status === ConnectionStatus.Disconnected) ||\n\t\t\tstatus === ConnectionStatus.Error\n\t\t) {\n\t\t\tthis.disconnected.resolve();\n\t\t\tthis.disconnected = newCompletable();\n\t\t} else {\n\t\t\tthis.status = status;\n\t\t\tthis.emitter.emit(status, args);\n\t\t}\n\t}\n\n\tprivate async requireStatus<T extends ConnectionStatus>(\n\t\tstatus: T,\n\t): Promise<true> {\n\t\tif (this.status !== status) {\n\t\t\tawait this.emitter.subscribeOnce(status);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tversion(url: URL, timeout?: number): Promise<string> {\n\t\treturn retrieveRemoteVersion(url, timeout);\n\t}\n\n\tasync connect(url: URL): Promise<void> {\n\t\tthis.connection.url = url;\n\n\t\t// Create an async loop\n\t\t(async () => {\n\t\t\tlet initial = true;\n\t\t\tlet controls: [() => void, (reason?: Error) => void] | undefined =\n\t\t\t\tundefined;\n\n\t\t\twhile (this.connection.url) {\n\t\t\t\tif (initial) {\n\t\t\t\t\tinitial = false;\n\t\t\t\t\tthis.setStatus(ConnectionStatus.Connecting);\n\t\t\t\t\tthis.ready = this.createSocket();\n\t\t\t\t\tawait this.disconnected.promise;\n\t\t\t\t} else {\n\t\t\t\t\t// Check if reconnecting is enabled\n\t\t\t\t\tif (!this.context.reconnect.enabled) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Configure controls for the promise if they are currently lacking\n\t\t\t\t\tif (!controls) {\n\t\t\t\t\t\tconst { promise, resolve, reject } = newCompletable();\n\t\t\t\t\t\tthis.ready = promise;\n\t\t\t\t\t\tcontrols = [resolve, reject];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Obtain the controls for the promise\n\t\t\t\t\tconst [resolve, reject] = controls;\n\n\t\t\t\t\t// Check if we will be allowed to iterate\n\t\t\t\t\tif (!this.context.reconnect.allowed) {\n\t\t\t\t\t\t// Clear the engine\n\t\t\t\t\t\tthis.connection = {\n\t\t\t\t\t\t\turl: undefined,\n\t\t\t\t\t\t\tnamespace: undefined,\n\t\t\t\t\t\t\tdatabase: undefined,\n\t\t\t\t\t\t\ttoken: undefined,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.socket = undefined;\n\t\t\t\t\t\treject(new ReconnectFailed());\n\n\t\t\t\t\t\t// Emit the ReconnectFailed error\n\t\t\t\t\t\tthis.emitter.emit(ConnectionStatus.Error, [new ReconnectFailed()]);\n\n\t\t\t\t\t\t// Emit the status\n\t\t\t\t\t\tthis.setStatus(ConnectionStatus.Disconnected);\n\n\t\t\t\t\t\t// Break the loop\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit the status\n\t\t\t\t\tthis.setStatus(ConnectionStatus.Reconnecting);\n\n\t\t\t\t\t// Try to iterate\n\t\t\t\t\tawait this.context.reconnect.iterate();\n\n\t\t\t\t\t// Attempt to reconnect\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.createSocket();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Ignore any error\n\t\t\t\t\t\t// the connection failed, let's try again\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Reconfigure the namespace and database\n\t\t\t\t\t\tif (this.connection.namespace || this.connection.database) {\n\t\t\t\t\t\t\tconst res = await this.rpc(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmethod: \"use\",\n\t\t\t\t\t\t\t\t\tparams: [this.connection.namespace, this.connection.database],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (res.error) {\n\t\t\t\t\t\t\t\tthrow new ResponseError(res.error.message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Reconfigure the authentication details\n\t\t\t\t\t\tif (this.connection.token) {\n\t\t\t\t\t\t\tconst res = await this.rpc(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmethod: \"authenticate\",\n\t\t\t\t\t\t\t\t\tparams: [this.connection.token],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (res.error) {\n\t\t\t\t\t\t\t\tthrow new ResponseError(res.error.message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// Clear the engine\n\t\t\t\t\t\tthis.connection = {\n\t\t\t\t\t\t\turl: undefined,\n\t\t\t\t\t\t\tnamespace: undefined,\n\t\t\t\t\t\t\tdatabase: undefined,\n\t\t\t\t\t\t\ttoken: undefined,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.socket = undefined;\n\t\t\t\t\t\treject(e as Error);\n\n\t\t\t\t\t\t// Emit the ReconnectFailed error\n\t\t\t\t\t\tthis.emitter.emit(ConnectionStatus.Error, [e as Error]);\n\n\t\t\t\t\t\t// Emit the status\n\t\t\t\t\t\tthis.setStatus(ConnectionStatus.Disconnected);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reset the reconnection status\n\t\t\t\t\tthis.context.reconnect.reset();\n\n\t\t\t\t\t// Unblock the connection\n\t\t\t\t\tresolve();\n\n\t\t\t\t\t// Scan all pending rpc requests\n\t\t\t\t\tconst pending = this.emitter.scanListeners((k) =>\n\t\t\t\t\t\tk.startsWith(\"rpc-\"),\n\t\t\t\t\t);\n\t\t\t\t\t// Ensure all rpc requests receive a retry symbol\n\t\t\t\t\tpending.map((k) => this.emitter.emit(k, [RetryMessage]));\n\n\t\t\t\t\t// If we are connection, wait for the connection to be dropped\n\t\t\t\t\tif (this.status === ConnectionStatus.Connected) {\n\t\t\t\t\t\tawait this.disconnected.promise;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\n\t\tawait this.ready;\n\t}\n\n\tprivate async createSocket() {\n\t\tconst { promise, resolve, reject } = newCompletable();\n\n\t\t// Validate requirements\n\t\tif (!this.connection.url) {\n\t\t\tthrow new NoURLProvided();\n\t\t}\n\n\t\t// Open a new connection\n\t\tconst socket = new WebSocket(this.connection.url.toString(), \"cbor\");\n\n\t\t// Wait for the connection to open\n\t\tsocket.addEventListener(\"open\", async () => {\n\t\t\tthis.socket = socket;\n\t\t\tawait this.context.prepare?.(new EngineAuth(this));\n\t\t\tthis.setStatus(ConnectionStatus.Connected);\n\t\t\tthis.pinger?.stop();\n\t\t\tthis.pinger = new Pinger(30000);\n\t\t\tthis.pinger.start(() => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.rpc({ method: \"ping\" });\n\t\t\t\t} catch {\n\t\t\t\t\t// we are not interested in the result\n\t\t\t\t}\n\t\t\t});\n\t\t\tresolve();\n\t\t});\n\n\t\t// Handle any errors\n\t\tsocket.addEventListener(\"error\", (e) => {\n\t\t\tconst error = new UnexpectedConnectionError(\n\t\t\t\t\"detail\" in e && e.detail\n\t\t\t\t\t? e.detail\n\t\t\t\t\t: \"message\" in e && e.message\n\t\t\t\t\t\t? e.message\n\t\t\t\t\t\t: \"error\" in e && e.error\n\t\t\t\t\t\t\t? e.error\n\t\t\t\t\t\t\t: \"An unexpected error occurred\",\n\t\t\t);\n\t\t\tthis.setStatus(ConnectionStatus.Error, error);\n\t\t\treject(error);\n\t\t});\n\n\t\t// Handle connection closure\n\t\tsocket.addEventListener(\"close\", () => {\n\t\t\tthis.setStatus(ConnectionStatus.Disconnected);\n\t\t\tthis.pinger?.stop();\n\t\t});\n\n\t\t// Handle any messages\n\t\tsocket.addEventListener(\"message\", async ({ data }) => {\n\t\t\ttry {\n\t\t\t\tconst decoded = this.decodeCbor(\n\t\t\t\t\tdata instanceof ArrayBuffer\n\t\t\t\t\t\t? data\n\t\t\t\t\t\t: data instanceof Blob\n\t\t\t\t\t\t\t? await data.arrayBuffer()\n\t\t\t\t\t\t\t: data.buffer.slice(\n\t\t\t\t\t\t\t\t\tdata.byteOffset,\n\t\t\t\t\t\t\t\t\tdata.byteOffset + data.byteLength,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t);\n\n\t\t\t\tif (\n\t\t\t\t\ttypeof decoded === \"object\" &&\n\t\t\t\t\tdecoded != null &&\n\t\t\t\t\tObject.getPrototypeOf(decoded) === Object.prototype\n\t\t\t\t) {\n\t\t\t\t\tthis.handleRpcResponse(decoded);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new UnexpectedServerResponse(decoded);\n\t\t\t\t}\n\t\t\t} catch (detail) {\n\t\t\t\tsocket.dispatchEvent(new CustomEvent(\"error\", { detail }));\n\t\t\t}\n\t\t});\n\n\t\tawait promise;\n\t}\n\n\tasync disconnect(): Promise<void> {\n\t\tthis.connection = {\n\t\t\turl: undefined,\n\t\t\tnamespace: undefined,\n\t\t\tdatabase: undefined,\n\t\t\ttoken: undefined,\n\t\t};\n\n\t\tawait this.ready?.catch(() => {});\n\t\tthis.socket?.close();\n\t\tthis.ready = undefined;\n\t\tthis.socket = undefined;\n\t\tthis.disconnected.resolve();\n\n\t\tawait Promise.any([\n\t\t\tthis.requireStatus(ConnectionStatus.Disconnected),\n\t\t\tthis.requireStatus(ConnectionStatus.Error),\n\t\t]);\n\t}\n\n\tasync rpc<\n\t\tMethod extends string,\n\t\tParams extends unknown[] | undefined,\n\t\tResult,\n\t>(\n\t\trequest: RpcRequest<Method, Params>,\n\t\tforce?: boolean,\n\t): Promise<RpcResponse<Result>> {\n\t\tif (!force) await this.ready;\n\t\tif (!this.socket) throw new ConnectionUnavailable();\n\n\t\tlet res: RpcResponse | undefined = undefined;\n\t\twhile (!res) {\n\t\t\t// It's not realistic for the message to ever arrive before the listener is registered on the emitter\n\t\t\t// And we don't want to collect the response messages in the emitter\n\t\t\t// So to be sure we simply subscribe before we send the message :)\n\n\t\t\tconst id = getIncrementalID();\n\t\t\tconst response = this.emitter.subscribeOnce(`rpc-${id}`);\n\t\t\tthis.socket.send(this.encodeCbor({ id, ...request }));\n\t\t\tif (force && this.socket.readyState === WebSocket.CLOSED)\n\t\t\t\tthrow new EngineDisconnected();\n\n\t\t\tconst [raw] = await response;\n\t\t\tif (raw instanceof EngineDisconnected) throw raw;\n\t\t\tif (raw === RetryMessage) continue;\n\t\t\tres = raw;\n\t\t}\n\n\t\tif (\"result\" in res) {\n\t\t\tswitch (request.method) {\n\t\t\t\tcase \"use\": {\n\t\t\t\t\tconst [ns, db] = request.params as [\n\t\t\t\t\t\tstring | null | undefined,\n\t\t\t\t\t\tstring | null | undefined,\n\t\t\t\t\t];\n\n\t\t\t\t\tif (ns === null) this.connection.namespace = undefined;\n\t\t\t\t\tif (db === null) this.connection.database = undefined;\n\t\t\t\t\tif (ns) this.connection.namespace = ns;\n\t\t\t\t\tif (db) this.connection.database = db;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"signin\":\n\t\t\t\tcase \"signup\": {\n\t\t\t\t\tthis.connection.token = res.result as string;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"authenticate\": {\n\t\t\t\t\tconst [token] = request.params as [string];\n\t\t\t\t\tthis.connection.token = token;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"invalidate\": {\n\t\t\t\t\tthis.connection.token = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res as RpcResponse<Result>;\n\t}\n\n\t// biome-ignore lint/suspicious/noExplicitAny: Cannot assume type\n\thandleRpcResponse({ id, ...res }: any): void {\n\t\tif (id) {\n\t\t\tthis.emitter.emit(`rpc-${id}`, [res]);\n\t\t} else if (res.error) {\n\t\t\tthis.setStatus(ConnectionStatus.Error, new ResponseError(res.error));\n\t\t} else {\n\t\t\tif (isLiveResult(res.result)) {\n\t\t\t\tconst { id, action, result } = res.result;\n\t\t\t\tthis.emitter.emit(`live-${id}`, [action, result], true);\n\t\t\t} else {\n\t\t\t\tthis.setStatus(\n\t\t\t\t\tConnectionStatus.Error,\n\t\t\t\t\tnew UnexpectedServerResponse({ id, ...res }),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tget connected(): boolean {\n\t\treturn !!this.socket;\n\t}\n\n\tasync export(options?: Partial<ExportOptions>): Promise<string> {\n\t\tif (!this.connection.url) {\n\t\t\tthrow new ConnectionUnavailable();\n\t\t}\n\t\tconst url = new URL(this.connection.url);\n\t\tconst basepath = url.pathname.slice(0, -4);\n\t\turl.protocol = url.protocol.replace(\"ws\", \"http\");\n\t\turl.pathname = `${basepath}/export`;\n\n\t\tconst buffer = await this.req_post(options ?? {}, url, {\n\t\t\tAccept: \"plain/text\",\n\t\t});\n\n\t\tconst dec = new TextDecoder(\"utf-8\");\n\t\treturn dec.decode(buffer);\n\t}\n\n\tasync import(data: string): Promise<void> {\n\t\tif (!this.connection.url) {\n\t\t\tthrow new ConnectionUnavailable();\n\t\t}\n\t\tconst url = new URL(this.connection.url);\n\t\tconst basepath = url.pathname.slice(0, -4);\n\t\turl.protocol = url.protocol.replace(\"ws\", \"http\");\n\t\turl.pathname = `${basepath}/import`;\n\n\t\tawait this.req_post(data, url, {\n\t\t\tAccept: \"application/json\",\n\t\t});\n\t}\n}\n\nexport class Pinger {\n\tprivate pinger?: ReturnType<typeof setTimeout>;\n\tprivate interval: number;\n\n\tconstructor(interval = 30000) {\n\t\tthis.interval = interval;\n\t}\n\n\tstart(callback: () => void): void {\n\t\tthis.pinger = setInterval(callback, this.interval);\n\t}\n\n\tstop(): void {\n\t\tclearInterval(this.pinger);\n\t}\n}\n", "export interface Completable<T = void> {\n\tpromise: Promise<T>;\n\tresolve: (arg: T) => void;\n\treject: (reason?: Error) => void;\n\tcompleted: boolean;\n}\n\nexport function newCompletable<T = void>(): Completable<T> {\n\tconst out = {\n\t\tcompleted: false,\n\t} as Completable<T>;\n\tout.promise = new Promise<T>((resolve_, reject_) => {\n\t\tout.resolve = (arg: T) => {\n\t\t\tout.completed = true;\n\t\t\tresolve_(arg);\n\t\t};\n\t\tout.reject = (reason?: Error) => {\n\t\t\tout.completed = true;\n\t\t\treject_(reason);\n\t\t};\n\t});\n\treturn out;\n}\n", "export function rand(min: number, max: number): number {\n\treturn Math.random() * (max - min) + min;\n}\n", "import { ReconnectIterationError } from \"../errors\";\nimport type { Surreal } from \"../surreal\";\nimport { DEFAULT_RECONNECT_OPTIONS, type ReconnectOptions } from \"../types\";\nimport { rand } from \"./rand\";\n\nexport class ReconnectContext {\n\tprivate _attempts = 0;\n\treadonly options: ReconnectOptions;\n\treadonly surreal: Surreal;\n\n\t// Process options as passed by the user\n\tconstructor(\n\t\tinput: undefined | Partial<ReconnectOptions> | boolean,\n\t\tsurreal: Surreal,\n\t) {\n\t\tthis.surreal = surreal;\n\n\t\tif (!input) {\n\t\t\tthis.options = {\n\t\t\t\t...DEFAULT_RECONNECT_OPTIONS,\n\t\t\t\tenabled: false,\n\t\t\t};\n\t\t} else if (input === true) {\n\t\t\tthis.options = DEFAULT_RECONNECT_OPTIONS;\n\t\t} else {\n\t\t\tthis.options = {\n\t\t\t\t...DEFAULT_RECONNECT_OPTIONS,\n\t\t\t\t...input,\n\t\t\t};\n\t\t}\n\t}\n\n\tget attempts(): number {\n\t\treturn this._attempts;\n\t}\n\n\tget enabled(): boolean {\n\t\treturn this.options.enabled;\n\t}\n\n\tget allowed(): boolean {\n\t\t// Check if reconnecting is enabled\n\t\tif (!this.options.enabled) return false;\n\n\t\t// Check if the maximum number of attempts has been reached\n\t\tif (\n\t\t\tthis.options.attempts !== -1 &&\n\t\t\tthis._attempts >= this.options.attempts\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treset(): void {\n\t\tthis._attempts = 0;\n\t}\n\n\tasync iterate(): Promise<void> {\n\t\t// Restrict reconnect attempts and propagate ReconnectFailed error\n\t\tif (!this.allowed) {\n\t\t\tthrow new ReconnectIterationError();\n\t\t}\n\n\t\t// Bump iteration\n\t\tthis._attempts++;\n\n\t\t// Compute the next reconnect delay\n\t\tconst multiplier = this.options.retryDelayMultiplier ** this.attempts;\n\t\tconst adjustedDelay = this.options.retryDelay * multiplier;\n\t\tconst jitterModifier = rand(\n\t\t\t-this.options.retryDelayJitter,\n\t\t\tthis.options.retryDelayJitter,\n\t\t);\n\n\t\tconst nextDelay = Math.min(\n\t\t\tadjustedDelay * (1 + jitterModifier),\n\t\t\tthis.options.retryDelayMax,\n\t\t);\n\n\t\t// Wait for the next iteration\n\t\tawait new Promise<void>((r) => setTimeout(r, nextDelay));\n\t}\n}\n", "import {\n\tStringRecordId,\n\tTable,\n\ttype Uuid,\n\tRecordId as _RecordId,\n\tdecodeCbor,\n\tencodeCbor,\n} from \"./data\";\nimport {\n\ttype AbstractEngine,\n\tConnectionStatus,\n\tEngineContext,\n\ttype EngineEvents,\n\ttype Engines,\n} from \"./engines/abstract.ts\";\nimport { Emitter } from \"./util/emitter.ts\";\nimport { PreparedQuery } from \"./util/prepared-query.ts\";\nimport { versionCheck } from \"./util/version-check.ts\";\n\nimport type {\n\tActionResult,\n\tConnectOptions,\n\tExportOptions,\n\tLiveHandler,\n\tMapQueryResult,\n\tPatch,\n\tPrettify,\n\tQueryParameters,\n\tRpcResponse,\n} from \"./types.ts\";\n\nimport { AuthController } from \"./auth.ts\";\nimport { type Fill, partiallyEncodeObject } from \"./cbor\";\nimport { replacer } from \"./data/cbor.ts\";\nimport type { RecordIdRange } from \"./data/types/range.ts\";\nimport { HttpEngine } from \"./engines/http.ts\";\nimport { WebsocketEngine } from \"./engines/ws.ts\";\nimport {\n\tEngineDisconnected,\n\tNoActiveSocket,\n\tResponseError,\n\tSurrealDbError,\n\tUnsupportedEngine,\n} from \"./errors.ts\";\nimport { ReconnectContext } from \"./util/reconnect.ts\";\n\ntype R = Prettify<Record<string, unknown>>;\ntype RecordId<Tb extends string = string> = _RecordId<Tb> | StringRecordId;\n\nexport class Surreal extends AuthController {\n\tpublic connection: AbstractEngine | undefined;\n\tpublic emitter: Emitter<EngineEvents>;\n\n\tprotected engines: Engines = {\n\t\tws: WebsocketEngine,\n\t\twss: WebsocketEngine,\n\t\thttp: HttpEngine,\n\t\thttps: HttpEngine,\n\t};\n\n\tprivate _ready?: Promise<void> | undefined;\n\n\tconstructor({\n\t\tengines,\n\t}: {\n\t\tengines?: Engines;\n\t} = {}) {\n\t\tsuper();\n\t\tthis.emitter = new Emitter();\n\n\t\tif (engines) {\n\t\t\tthis.engines = {\n\t\t\t\t...this.engines,\n\t\t\t\t...engines,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Establish a socket connection to the database\n\t * @param connection - Connection details\n\t */\n\tasync connect(url: string | URL, opts: ConnectOptions = {}): Promise<true> {\n\t\tthis._ready = this.connectInner(url, opts);\n\t\tawait this._ready;\n\t\treturn true;\n\t}\n\n\tprivate async connectInner(\n\t\turl: string | URL,\n\t\topts: ConnectOptions = {},\n\t): Promise<void> {\n\t\tconst endpoint = parseUrl(url);\n\t\tconst engineName = endpoint.protocol.slice(0, -1);\n\t\tconst engine = this.engines[engineName];\n\t\tif (!engine) throw new UnsupportedEngine(engineName);\n\n\t\t// Process options\n\t\tconst { prepare, auth, namespace, database, reconnect } = opts;\n\n\t\t// Close any existing connections\n\t\tawait this.close();\n\n\t\t// We need to pass CBOR encoding and decoding functions as an argument to engines,\n\t\t// to ensure that everything is using the same instance of classes that these methods depend on.\n\t\tconst context = new EngineContext({\n\t\t\temitter: this.emitter,\n\t\t\tencodeCbor,\n\t\t\tdecodeCbor,\n\t\t\treconnect: new ReconnectContext(reconnect, this),\n\t\t\tprepare,\n\t\t});\n\n\t\t// The promise does not know if `this.connection` is undefined or not, but it does about `connection`\n\t\tconst connection = new engine(context);\n\n\t\t// If not disabled, run a version check\n\t\tif (opts.versionCheck !== false) {\n\t\t\tconst version = await connection.version(\n\t\t\t\tendpoint,\n\t\t\t\topts.versionCheckTimeout,\n\t\t\t);\n\t\t\tversionCheck(version);\n\t\t}\n\n\t\tthis.connection = connection;\n\n\t\tawait connection.connect(endpoint);\n\n\t\tif (namespace || database) {\n\t\t\tawait this.use({\n\t\t\t\tnamespace,\n\t\t\t\tdatabase,\n\t\t\t});\n\t\t}\n\n\t\tif (typeof auth === \"string\") {\n\t\t\tawait this.authenticate(auth);\n\t\t} else if (auth) {\n\t\t\tawait this.signin(auth);\n\t\t}\n\t}\n\n\t/**\n\t * Disconnect the socket to the database\n\t */\n\tasync close(): Promise<true> {\n\t\tthis.clean();\n\t\tawait this.connection?.disconnect();\n\t\treturn true;\n\t}\n\n\tprivate clean() {\n\t\t// Scan all pending rpc requests\n\t\tconst pending = this.emitter.scanListeners((k) => k.startsWith(\"rpc-\"));\n\t\t// Ensure all rpc requests get a connection closed response\n\t\tpending.map((k) => this.emitter.emit(k, [new EngineDisconnected()]));\n\n\t\t// Scan all active live listeners\n\t\tconst live = this.emitter.scanListeners((k) => k.startsWith(\"live-\"));\n\t\t// Ensure all live listeners get a CLOSE message with disconnected as reason\n\t\tlive.map((k) => this.emitter.emit(k, [\"CLOSE\", \"disconnected\"]));\n\n\t\t// Cleanup subscriptions and yet to be collected emisions\n\t\tthis.emitter.reset({\n\t\t\tcollectable: true,\n\t\t\tlisteners: [...pending, ...live],\n\t\t});\n\t}\n\n\t/**\n\t * Check if connection is ready\n\t */\n\tget status(): ConnectionStatus {\n\t\treturn this.connection?.status ?? ConnectionStatus.Disconnected;\n\t}\n\n\t/**\n\t * A promise which resolves when the connection is ready\n\t */\n\tget ready(): Promise<void> {\n\t\treturn Promise.all([this._ready, this.connection?.ready]).then(() => {});\n\t}\n\n\t/**\n\t * Ping SurrealDB instance\n\t */\n\tasync ping(): Promise<true> {\n\t\tconst { error } = await this.rpc(\"ping\");\n\t\tif (error) throw new ResponseError(error.message);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Switch to a specific namespace and database.\n\t * @param database - Switches to a specific namespace.\n\t * @param db - Switches to a specific database.\n\t */\n\tasync use({\n\t\tnamespace,\n\t\tdatabase,\n\t}: {\n\t\tnamespace?: string | null;\n\t\tdatabase?: string | null;\n\t}): Promise<true> {\n\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t\tif (namespace === null && database !== null)\n\t\t\tthrow new SurrealDbError(\n\t\t\t\t\"Cannot unset namespace without unsetting database\",\n\t\t\t);\n\t\tconst { error } = await this.rpc(\"use\", [namespace, database]);\n\t\tif (error) throw new ResponseError(error.message);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Selects everything from the [$auth](https://surrealdb.com/docs/surrealql/parameters) variable.\n\t * ```sql\n\t * SELECT * FROM $auth;\n\t * ```\n\t * Make sure the user actually has the permission to select their own record, otherwise you'll get back an empty result.\n\t * @return The record linked to the record ID used for authentication\n\t */\n\tasync info<T extends R>(): Promise<ActionResult<T> | undefined> {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T> | undefined>(\"info\");\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result ?? undefined;\n\t}\n\n\t/**\n\t * Specify a variable for the current socket connection.\n\t * @param key - Specifies the name of the variable.\n\t * @param val - Assigns the value to the variable name.\n\t */\n\tasync let(variable: string, value: unknown): Promise<true> {\n\t\tconst res = await this.rpc(\"let\", [variable, value]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Remove a variable from the current socket connection.\n\t * @param key - Specifies the name of the variable.\n\t */\n\tasync unset(variable: string): Promise<true> {\n\t\tconst res = await this.rpc(\"unset\", [variable]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Start a live select query and invoke the callback with responses\n\t * @param table - The table that you want to receive live results for.\n\t * @param callback - Callback function that receives updates.\n\t * @param diff - If set to true, will return a set of patches instead of complete records\n\t * @returns A unique subscription ID\n\t */\n\tasync live<\n\t\tResult extends Record<string, unknown> | Patch = Record<string, unknown>,\n\t>(\n\t\ttable: RecordIdRange | Table | string,\n\t\tcallback?: LiveHandler<Result>,\n\t\tdiff?: boolean,\n\t): Promise<Uuid> {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<Uuid>(\"live\", [table, diff]);\n\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\tif (callback) this.subscribeLive<Result>(res.result, callback);\n\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Subscribe to an existing live select query and invoke the callback with responses\n\t * @param queryUuid - The unique ID of an existing live query you want to receive updates for.\n\t * @param callback - Callback function that receives updates.\n\t */\n\tasync subscribeLive<\n\t\tResult extends Record<string, unknown> | Patch = Record<string, unknown>,\n\t>(queryUuid: Uuid, callback: LiveHandler<Result>): Promise<void> {\n\t\tawait this.ready;\n\t\tif (!this.connection) throw new NoActiveSocket();\n\t\tthis.connection.emitter.subscribe(\n\t\t\t`live-${queryUuid}`,\n\t\t\tcallback as LiveHandler,\n\t\t\ttrue,\n\t\t);\n\t}\n\n\t/**\n\t * Unsubscribe a callback from a live select query\n\t * @param queryUuid - The unique ID of an existing live query you want to ubsubscribe from.\n\t * @param callback - The previously subscribed callback function.\n\t */\n\tasync unSubscribeLive<\n\t\tResult extends Record<string, unknown> | Patch = Record<string, unknown>,\n\t>(queryUuid: Uuid, callback: LiveHandler<Result>): Promise<void> {\n\t\tawait this.ready;\n\t\tif (!this.connection) throw new NoActiveSocket();\n\t\tthis.connection.emitter.unSubscribe(\n\t\t\t`live-${queryUuid}`,\n\t\t\tcallback as LiveHandler,\n\t\t);\n\t}\n\n\t/**\n\t * Kill a live query\n\t * @param queryUuid - The query that you want to kill.\n\t */\n\tasync kill(queryUuid: Uuid | readonly Uuid[]): Promise<void> {\n\t\tawait this.ready;\n\t\tif (!this.connection) throw new NoActiveSocket();\n\t\tif (Array.isArray(queryUuid)) {\n\t\t\tawait Promise.all(queryUuid.map((u) => this.rpc(\"kill\", [u])));\n\t\t\tconst toBeKilled = queryUuid.map((u) => `live-${u}` as const);\n\t\t\ttoBeKilled.map((k) => this.emitter.emit(k, [\"CLOSE\", \"killed\"]));\n\t\t\tthis.connection.emitter.reset({\n\t\t\t\tcollectable: toBeKilled,\n\t\t\t\tlisteners: toBeKilled,\n\t\t\t});\n\t\t} else {\n\t\t\tawait this.rpc(\"kill\", [queryUuid]);\n\t\t\tthis.emitter.emit(`live-${queryUuid}`, [\"CLOSE\", \"killed\"]);\n\t\t\tthis.connection.emitter.reset({\n\t\t\t\tcollectable: `live-${queryUuid}`,\n\t\t\t\tlisteners: `live-${queryUuid}`,\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Runs a set of SurrealQL statements against the database.\n\t * @param query - Specifies the SurrealQL statements.\n\t * @param bindings - Assigns variables which can be used in the query.\n\t */\n\tasync query<T extends unknown[]>(\n\t\t...args: QueryParameters\n\t): Promise<Prettify<T>> {\n\t\tconst raw = await this.queryRaw<T>(...args);\n\t\treturn raw.map(({ status, result }) => {\n\t\t\tif (status === \"ERR\") throw new ResponseError(result);\n\t\t\treturn result;\n\t\t}) as T;\n\t}\n\n\t/**\n\t * Runs a set of SurrealQL statements against the database.\n\t * @param query - Specifies the SurrealQL statements.\n\t * @param bindings - Assigns variables which can be used in the query.\n\t */\n\tasync queryRaw<T extends unknown[]>(\n\t\t...[q, b]: QueryParameters\n\t): Promise<Prettify<MapQueryResult<T>>> {\n\t\tconst params =\n\t\t\tq instanceof PreparedQuery\n\t\t\t\t? [\n\t\t\t\t\t\tq.query,\n\t\t\t\t\t\tpartiallyEncodeObject(q.bindings, {\n\t\t\t\t\t\t\tfills: b as Fill[],\n\t\t\t\t\t\t\treplacer: replacer.encode,\n\t\t\t\t\t\t}),\n\t\t\t\t\t]\n\t\t\t\t: [q, b];\n\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<MapQueryResult<T>>(\"query\", params);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Runs a set of SurrealQL statements against the database.\n\t * @param query - Specifies the SurrealQL statements.\n\t * @param bindings - Assigns variables which can be used in the query.\n\t * @deprecated Use `queryRaw` instead\n\t */\n\tasync query_raw<T extends unknown[]>(\n\t\t...args: QueryParameters\n\t): Promise<Prettify<MapQueryResult<T>>> {\n\t\treturn this.queryRaw<T>(...args);\n\t}\n\n\t/**\n\t * Selects all records in a table, or a specific record, from the database.\n\t * If you intend on sorting, filtering, or performing other operations on the data, it is recommended to use the `query` method instead.\n\t * @param thing - The table name or a record ID to select.\n\t */\n\tasync select<T extends R>(thing: RecordId): Promise<ActionResult<T>>;\n\tasync select<T extends R>(\n\t\tthing: RecordIdRange | Table | string,\n\t): Promise<ActionResult<T>[]>;\n\tasync select<T extends R>(thing: RecordId | RecordIdRange | Table | string) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"select\", [thing]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Creates a record in the database.\n\t * @param thing - The table name or the specific record ID to create.\n\t * @param data - The document / record data to insert.\n\t */\n\tasync create<T extends R, U extends R = T>(\n\t\tthing: RecordId,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>>;\n\tasync create<T extends R, U extends R = T>(\n\t\tthing: Table | string,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>[]>;\n\tasync create<T extends R, U extends R = T>(\n\t\tthing: RecordId | Table | string,\n\t\tdata?: U,\n\t) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"create\", [thing, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Inserts one or multiple records in the database.\n\t * @param table - The table name to insert into.\n\t * @param data - The document(s) / record(s) to insert.\n\t */\n\tasync insert<T extends R, U extends R = T>(\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insert<T extends R, U extends R = T>(\n\t\ttable: Table | string,\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insert<T extends R, U extends R = T>(\n\t\targ1: Table | string | U | U[],\n\t\targ2?: U | U[],\n\t) {\n\t\tawait this.ready;\n\t\tconst [table, data] =\n\t\t\ttypeof arg1 === \"string\" || arg1 instanceof Table\n\t\t\t\t? [arg1, arg2]\n\t\t\t\t: [undefined, arg1];\n\t\tconst res = await this.rpc<ActionResult<T>>(\"insert\", [table, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Inserts one or multiple records in the database.\n\t * @param thing - The table name or the specific record ID to create.\n\t * @param data - The document(s) / record(s) to insert.\n\t */\n\tasync insertRelation<T extends R, U extends R = T>(\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insertRelation<T extends R, U extends R = T>(\n\t\ttable: Table | string,\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insertRelation<T extends R, U extends R = T>(\n\t\targ1: Table | string | U | U[],\n\t\targ2?: U | U[],\n\t) {\n\t\tawait this.ready;\n\t\tconst [table, data] =\n\t\t\ttypeof arg1 === \"string\" || arg1 instanceof Table\n\t\t\t\t? [arg1, arg2]\n\t\t\t\t: [undefined, arg1];\n\t\tconst res = await this.rpc<ActionResult<T>>(\"insert_relation\", [\n\t\t\ttable,\n\t\t\tdata,\n\t\t]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Inserts one or multiple records in the database.\n\t * @param thing - The table name or the specific record ID to create.\n\t * @param data - The document(s) / record(s) to insert.\n\t * @deprecated Use `insertRelation` instead\n\t */\n\tasync insert_relation<T extends R, U extends R = T>(\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insert_relation<T extends R, U extends R = T>(\n\t\ttable: Table | string,\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insert_relation<T extends R, U extends R = T>(\n\t\targ1: Table | string | U | U[],\n\t\targ2?: U | U[],\n\t) {\n\t\treturn arg1 instanceof Table || typeof arg1 === \"string\"\n\t\t\t? this.insertRelation(arg1, arg2)\n\t\t\t: this.insertRelation(arg1);\n\t}\n\n\t/**\n\t * Updates all records in a table, or a specific record, in the database.\n\t *\n\t * ***NOTE: This function replaces the current document / record data with the specified data.***\n\t * @param thing - The table name or the specific record ID to update.\n\t * @param data - The document / record data to insert.\n\t */\n\tasync update<T extends R, U extends R = T>(\n\t\tthing: RecordId,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>>;\n\tasync update<T extends R, U extends R = T>(\n\t\tthing: RecordIdRange | Table | string,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>[]>;\n\tasync update<T extends R, U extends R = T>(\n\t\tthing: RecordId | RecordIdRange | Table | string,\n\t\tdata?: U,\n\t) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"update\", [thing, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Upserts all records in a table, or a specific record, in the database.\n\t *\n\t * ***NOTE: This function replaces the current document / record data with the specified data.***\n\t * @param thing - The table name or the specific record ID to upsert.\n\t * @param data - The document / record data to insert.\n\t */\n\tasync upsert<T extends R, U extends R = T>(\n\t\tthing: RecordId,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>>;\n\tasync upsert<T extends R, U extends R = T>(\n\t\tthing: RecordIdRange | Table | string,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>[]>;\n\tasync upsert<T extends R, U extends R = T>(\n\t\tthing: RecordId | RecordIdRange | Table | string,\n\t\tdata?: U,\n\t) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"upsert\", [thing, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Modifies all records in a table, or a specific record, in the database.\n\t *\n\t * ***NOTE: This function merges the current document / record data with the specified data.***\n\t * @param thing - The table name or the specific record ID to change.\n\t * @param data - The document / record data to insert.\n\t */\n\tasync merge<T extends R, U extends R = Partial<T>>(\n\t\tthing: RecordId,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>>;\n\tasync merge<T extends R, U extends R = Partial<T>>(\n\t\tthing: RecordIdRange | Table | string,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>[]>;\n\tasync merge<T extends R, U extends R = Partial<T>>(\n\t\tthing: RecordId | RecordIdRange | Table | string,\n\t\tdata?: U,\n\t) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"merge\", [thing, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Applies JSON Patch changes to all records, or a specific record, in the database.\n\t *\n\t * ***NOTE: This function patches the current document / record data with the specified JSON Patch data.***\n\t * @param thing - The table name or the specific record ID to modify.\n\t * @param data - The JSON Patch data with which to modify the records.\n\t */\n\tasync patch<T extends R>(\n\t\tthing: RecordId,\n\t\tdata?: Patch[],\n\t\tdiff?: false,\n\t): Promise<ActionResult<T>>;\n\tasync patch<T extends R>(\n\t\tthing: RecordIdRange | Table | string,\n\t\tdata?: Patch[],\n\t\tdiff?: false,\n\t): Promise<ActionResult<T>[]>;\n\tasync patch<T extends R>(\n\t\tthing: RecordId,\n\t\tdata: undefined | Patch[],\n\t\tdiff: true,\n\t): Promise<Patch[]>;\n\tasync patch<T extends R>(\n\t\tthing: RecordIdRange | Table | string,\n\t\tdata: undefined | Patch[],\n\t\tdiff: true,\n\t): Promise<Patch[][]>;\n\tasync patch(\n\t\tthing: RecordId | RecordIdRange | Table | string,\n\t\tdata?: Patch[],\n\t\tdiff?: boolean,\n\t) {\n\t\tawait this.ready;\n\n\t\t// biome-ignore lint/suspicious/noExplicitAny: Cannot assume type here due to function overload\n\t\tconst res = await this.rpc<any>(\"patch\", [thing, data, diff]);\n\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn diff ? res.result : output(thing, res.result);\n\t}\n\n\t/**\n\t * Deletes all records in a table, or a specific record, from the database.\n\t * @param thing - The table name or a record ID to select.\n\t */\n\tasync delete<T extends R>(thing: RecordId): Promise<ActionResult<T>>;\n\tasync delete<T extends R>(\n\t\tthing: RecordIdRange | Table | string,\n\t): Promise<ActionResult<T>[]>;\n\tasync delete<T extends R>(thing: RecordId | RecordIdRange | Table | string) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"delete\", [thing]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Obtain the version of the SurrealDB instance\n\t * @example `surrealdb-2.1.0`\n\t */\n\tasync version(): Promise<string> {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<string>(\"version\");\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Run a SurrealQL function\n\t * @param name - The full name of the function\n\t * @param args - The arguments supplied to the function. You can also supply a version here as a string, in which case the third argument becomes the parameter list.\n\t */\n\tasync run<T>(name: string, args?: unknown[]): Promise<T>;\n\t/**\n\t * Run a SurrealQL function\n\t * @param name - The full name of the function\n\t * @param version - The version of the function. If omitted, the second argument is the parameter list.\n\t * @param args - The arguments supplied to the function.\n\t */\n\tasync run<T>(name: string, version: string, args?: unknown[]): Promise<T>;\n\tasync run(name: string, arg2?: string | unknown[], arg3?: unknown[]) {\n\t\tawait this.ready;\n\t\tconst [version, args] = Array.isArray(arg2)\n\t\t\t? [undefined, arg2]\n\t\t\t: [arg2, arg3];\n\n\t\tconst res = await this.rpc(\"run\", [name, version, args]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Obtain the version of the SurrealDB instance\n\t * @param from - The in property on the edge record\n\t * @param thing - The id of the edge record\n\t * @param to - The out property on the edge record\n\t * @param data - Optionally, provide a body for the edge record\n\t */\n\tasync relate<T extends R, U extends R = T>(\n\t\tfrom: string | RecordId | RecordId[],\n\t\tthing: RecordId,\n\t\tto: string | RecordId | RecordId[],\n\t\tdata?: U,\n\t): Promise<T>;\n\tasync relate<T extends R, U extends R = T>(\n\t\tfrom: string | RecordId | RecordId[],\n\t\tthing: string,\n\t\tto: string | RecordId | RecordId[],\n\t\tdata?: U,\n\t): Promise<T[]>;\n\tasync relate<T extends R, U extends R = T>(\n\t\tfrom: string | RecordId | RecordId[],\n\t\tthing: string | RecordId,\n\t\tto: string | RecordId | RecordId[],\n\t\tdata?: U,\n\t) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc(\"relate\", [from, thing, to, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Send a raw message to the SurrealDB instance\n\t * @param method - Type of message to send.\n\t * @param params - Parameters for the message.\n\t */\n\tpublic rpc<Result>(\n\t\tmethod: string,\n\t\tparams?: unknown[],\n\t): Promise<RpcResponse<Result>> {\n\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t\treturn this.connection.rpc<typeof method, typeof params, Result>({\n\t\t\tmethod,\n\t\t\tparams,\n\t\t});\n\t}\n\n\t/**\n\t * Export the database and return the result as a string\n\t * @param options - Export configuration options\n\t */\n\tpublic async export(options?: Partial<ExportOptions>): Promise<string> {\n\t\tawait this.ready;\n\t\tif (!this.connection) throw new NoActiveSocket();\n\t\treturn this.connection.export(options);\n\t}\n\n\t/**\n\t * Import an existing export into the database\n\t * @param input - The data to import\n\t */\n\tpublic async import(input: string): Promise<void> {\n\t\tawait this.ready;\n\t\tif (!this.connection) throw new NoActiveSocket();\n\t\treturn this.connection.import(input);\n\t}\n}\n\ntype Output<T, S> = S extends RecordId ? T : T[];\nfunction output<T, S>(subject: S, input: T | T[]): Output<T, S> {\n\tconst one = subject instanceof _RecordId || subject instanceof StringRecordId;\n\tif (one) return (Array.isArray(input) ? input[0] : input) as Output<T, S>;\n\treturn (Array.isArray(input) ? input : [input]) as Output<T, S>;\n}\n\nfunction parseUrl(value: string | URL): URL {\n\tconst url = new URL(value);\n\n\tif (!url.pathname.endsWith(\"/rpc\")) {\n\t\tif (!url.pathname.endsWith(\"/\")) url.pathname += \"/\";\n\t\turl.pathname += \"rpc\";\n\t}\n\n\treturn url;\n}\n\nfunction rand(min: number, max: number) {\n\treturn Math.random() * (max - min) + min;\n}\n"],
  "mappings": "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",
  "names": ["replacer", "replacer", "input", "s", "f", "r", "r", "arr", "decode", "s", "s", "id", "output", "output", "textEncoder", "id", "version", "ConnectionStatus", "encodeCbor", "decodeCbor", "r", "id", "resolve", "reject", "id", "r", "u"]
}
