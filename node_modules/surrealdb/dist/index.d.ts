// Generated by dts-bundle-generator v9.5.1

import { UUID } from 'uuidv7';

export type Listener<Args extends unknown[] = unknown[]> = (...args: Args) => unknown;
export type UnknownEvents = Record<string, unknown[]>;
/**
 * A class used to subscribe to and emit events
 */
export declare class Emitter<Events extends UnknownEvents = UnknownEvents> {
	private collectable;
	private listeners;
	private readonly interceptors;
	constructor({ interceptors, }?: {
		interceptors?: Partial<{
			[K in keyof Events]: (...args: Events[K]) => Promise<Events[K]>;
		}>;
	});
	subscribe<Event extends keyof Events>(event: Event, listener: Listener<Events[Event]>, historic?: boolean): void;
	subscribeOnce<Event extends keyof Events>(event: Event, historic?: boolean): Promise<Events[Event]>;
	unSubscribe<Event extends keyof Events>(event: Event, listener: Listener<Events[Event]>): void;
	isSubscribed<Event extends keyof Events>(event: Event, listener: Listener<Events[Event]>): boolean;
	emit<Event extends keyof Events>(event: Event, args: Events[Event], collectable?: boolean): Promise<void>;
	reset({ collectable, listeners, }: {
		collectable?: boolean | keyof Events | (keyof Events)[];
		listeners?: boolean | keyof Events | (keyof Events)[];
	}): void;
	scanListeners(filter?: (k: keyof Events) => boolean): (keyof Events)[];
}
type Replacer = (v: unknown) => unknown;
type Major = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;
declare const POW_2_53: number;
declare const POW_2_64: bigint;
export type Fill<T = unknown> = [
	Gap<T>,
	T
];
export declare class Gap<T = unknown> {
	readonly args: [
		T?
	];
	constructor(...args: [
		T?
	]);
	fill(value: T): Fill<T>;
	hasDefault(): boolean;
	get default(): T | undefined;
}
declare class PartiallyEncoded {
	readonly chunks: [
		ArrayBuffer,
		Gap
	][];
	readonly end: ArrayBuffer;
	readonly replacer: Replacer | undefined;
	constructor(chunks: [
		ArrayBuffer,
		Gap
	][], end: ArrayBuffer, replacer: Replacer | undefined);
	build<Partial extends boolean = false>(fills: Fill[], partial?: Partial): Partial extends true ? PartiallyEncoded : ArrayBuffer;
}
declare function partiallyEncodeObject(object: Record<string, unknown>, options?: EncoderOptions<true>): Record<string, PartiallyEncoded>;
declare class Writer {
	readonly byteLength: number;
	private _chunks;
	private _pos;
	private _buf;
	private _view;
	private _byte;
	constructor(byteLength?: number);
	chunk(gap: Gap): void;
	get chunks(): [
		ArrayBuffer,
		Gap
	][];
	get buffer(): ArrayBuffer;
	private claim;
	writeUint8(value: number): void;
	writeUint16(value: number): void;
	writeUint32(value: number): void;
	writeUint64(value: bigint): void;
	writeUint8Array(data: Uint8Array): void;
	writeArrayBuffer(data: ArrayBuffer): void;
	writePartiallyEncoded(data: PartiallyEncoded): void;
	writeFloat32(value: number): void;
	writeFloat64(value: number): void;
	writeMajor(type: Major, length: number | bigint): void;
	output<Partial extends boolean = false>(partial: Partial, replacer?: Replacer): Partial extends true ? PartiallyEncoded : ArrayBuffer;
}
interface EncoderOptions<Partial extends boolean> {
	replacer?: Replacer;
	writer?: Writer;
	partial?: Partial;
	fills?: Fill[];
}
declare function encode<Partial extends boolean = false>(input: unknown, options?: EncoderOptions<Partial>): Partial extends true ? PartiallyEncoded : ArrayBuffer;
declare class Reader {
	private _buf;
	private _view;
	private _byte;
	private _pos;
	constructor(buffer: ArrayBufferLike);
	private read;
	readUint8(): number;
	readUint16(): number;
	readUint32(): number;
	readUint64(): bigint;
	readFloat16(): number;
	readFloat32(): number;
	readFloat64(): number;
	readBytes(amount: number): Uint8Array;
	readMajor(): [
		Major,
		number
	];
	readMajorLength(length: number): number | bigint;
}
interface DecodeOptions {
	map?: "object" | "map";
	replacer?: Replacer;
}
declare function decode(input: ArrayBufferLike | Reader, options?: DecodeOptions): any;
declare function infiniteBytes(r: Reader, forMajor: Major): ArrayBuffer;
declare class Tagged<T = unknown> {
	readonly tag: number | bigint;
	readonly value: T;
	constructor(tag: number | bigint, value: T);
}
export declare class SurrealDbError extends Error {
}
export declare class NoActiveSocket extends SurrealDbError {
	name: string;
	message: string;
}
export declare class NoConnectionDetails extends SurrealDbError {
	name: string;
	message: string;
}
export declare class UnexpectedResponse extends SurrealDbError {
	name: string;
	message: string;
}
export declare class InvalidURLProvided extends SurrealDbError {
	name: string;
	message: string;
}
export declare class NoURLProvided extends SurrealDbError {
	name: string;
	message: string;
}
export declare class EngineDisconnected extends SurrealDbError {
	name: string;
	message: string;
}
export declare class ReconnectFailed extends SurrealDbError {
	name: string;
	message: string;
}
export declare class ReconnectIterationError extends SurrealDbError {
	name: string;
	message: string;
}
export declare class UnexpectedServerResponse extends SurrealDbError {
	readonly response: unknown;
	name: string;
	constructor(response: unknown);
}
export declare class UnexpectedConnectionError extends SurrealDbError {
	readonly error: unknown;
	name: string;
	constructor(error: unknown);
}
export declare class UnsupportedEngine extends SurrealDbError {
	readonly engine: string;
	name: string;
	message: string;
	constructor(engine: string);
}
export declare class FeatureUnavailableForEngine extends SurrealDbError {
	name: string;
	message: string;
}
export declare class ConnectionUnavailable extends SurrealDbError {
	name: string;
	message: string;
}
export declare class MissingNamespaceDatabase extends SurrealDbError {
	name: string;
	message: string;
}
export declare class HttpConnectionError extends SurrealDbError {
	readonly message: string;
	readonly status: number;
	readonly statusText: string;
	readonly buffer: ArrayBuffer;
	name: string;
	constructor(message: string, status: number, statusText: string, buffer: ArrayBuffer);
}
export declare class ResponseError extends SurrealDbError {
	readonly message: string;
	name: string;
	constructor(message: string);
}
export declare class NoNamespaceSpecified extends SurrealDbError {
	name: string;
	message: string;
}
export declare class NoDatabaseSpecified extends SurrealDbError {
	name: string;
	message: string;
}
export declare class NoTokenReturned extends SurrealDbError {
	name: string;
	message: string;
}
export declare class UnsupportedVersion extends SurrealDbError {
	name: string;
	version: string;
	supportedRange: string;
	constructor(version: string, supportedRange: string);
}
export declare class VersionRetrievalFailure extends SurrealDbError {
	readonly error?: Error | undefined;
	name: string;
	message: string;
	constructor(error?: Error | undefined);
}
export declare abstract class CborError extends SurrealDbError {
	abstract readonly name: string;
	readonly message: string;
	constructor(message: string);
}
export declare class CborNumberError extends CborError {
	name: string;
}
export declare class CborRangeError extends CborError {
	name: string;
}
export declare class CborInvalidMajorError extends CborError {
	name: string;
}
export declare class CborBreak extends CborError {
	name: string;
	constructor();
}
export declare class CborPartialDisabled extends CborError {
	name: string;
	constructor();
}
export declare class CborFillMissing extends CborError {
	name: string;
	constructor();
}
declare class Encoded {
	readonly encoded: ArrayBuffer;
	constructor(encoded: ArrayBuffer);
}
/**
 * A query and its bindings prepared for execution, which can be passed to the .query() method.
 */
export declare class PreparedQuery {
	private _query;
	private _bindings;
	private length;
	constructor(query: string, bindings?: Record<string, unknown>);
	/**
	 * Retrieves the encoded query string.
	 */
	get query(): Encoded;
	/**
	 * Retrieves the encoded bindings.
	 */
	get bindings(): Record<string, PartiallyEncoded>;
	/**
	 * Compile this query and its bindings into a single ArrayBuffer, optionally filling gaps.
	 * @param fills - The gap values to fill
	 */
	build(fills?: Fill[]): ArrayBuffer;
	/**
	 * A template literal tag function for appending additional query segments and bindings to the prepared query.
	 * @param query_raw - The additional query segments to append
	 * @param values - The additional interpolated values to append
	 * @example
	 * const query = surrealql`SELECT * FROM person`;
	 *
	 * if (filter) {
	 *   query.append` WHERE name = ${filter}`;
	 * }
	 */
	append(query_raw: string[] | TemplateStringsArray, ...values: unknown[]): PreparedQuery;
}
/**
 * A template literal tag function for creating prepared queries from query strings.
 * Interpolated values are automatically stored as bindings.
 * @param query_raw - The raw query string
 * @param values - The interpolated values
 * @example const query = surrealql`SELECT * FROM ${id}`;
 * @returns A PreparedQuery instance
 */
export declare function surrealql(query_raw: string[] | TemplateStringsArray, ...values: unknown[]): PreparedQuery;
declare abstract class Value {
	/**
	 * Compare equality with another value.
	 */
	abstract equals(other: unknown): boolean;
	/**
	 * Convert this value to a serializable string
	 */
	abstract toJSON(): unknown;
	/**
	 * Convert this value to a string representation
	 */
	abstract toString(): string;
}
/**
 * A SurrealQL UUID value.
 */
export declare class Uuid extends Value {
	private readonly inner;
	constructor(uuid: string | ArrayBuffer | Uint8Array | Uuid | UUID);
	equals(other: unknown): boolean;
	toString(): string;
	toJSON(): string;
	toUint8Array(): Uint8Array;
	toBuffer(): ArrayBufferLike;
	static v4(): Uuid;
	static v7(): Uuid;
}
export type RecordIdValue = string | number | Uuid | bigint | unknown[] | Record<string, unknown>;
/**
 * A SurrealQL record ID value.
 */
export declare class RecordId<Tb extends string = string> extends Value {
	readonly tb: Tb;
	readonly id: RecordIdValue;
	constructor(tb: Tb, id: RecordIdValue);
	equals(other: unknown): boolean;
	toJSON(): string;
	toString(): string;
}
/**
 * A SurrealQL string-represented record ID value.
 */
export declare class StringRecordId extends Value {
	readonly rid: string;
	constructor(rid: string | StringRecordId | RecordId);
	equals(other: unknown): boolean;
	toJSON(): string;
	toString(): string;
}
/**
 * A SurrealQL range value.
 */
declare class Range$1<Beg, End> extends Value {
	readonly beg: Bound<Beg>;
	readonly end: Bound<End>;
	constructor(beg: Bound<Beg>, end: Bound<End>);
	equals(other: unknown): boolean;
	toJSON(): string;
	toString(): string;
}
export type Bound<T> = BoundIncluded<T> | BoundExcluded<T> | undefined;
export declare class BoundIncluded<T> {
	readonly value: T;
	constructor(value: T);
}
export declare class BoundExcluded<T> {
	readonly value: T;
	constructor(value: T);
}
/**
 * A SurrealQL record ID range value.
 */
export declare class RecordIdRange<Tb extends string = string> extends Value {
	readonly tb: Tb;
	readonly beg: Bound<RecordIdValue>;
	readonly end: Bound<RecordIdValue>;
	constructor(tb: Tb, beg: Bound<RecordIdValue>, end: Bound<RecordIdValue>);
	equals(other: unknown): boolean;
	toJSON(): string;
	toString(): string;
}
/**
 * An uncomputed SurrealQL future value.
 */
export declare class Future extends Value {
	readonly inner: string;
	constructor(inner: string);
	equals(other: unknown): boolean;
	toJSON(): string;
	toString(): string;
}
/**
 * A SurrealQL duration value.
 */
export declare class Duration extends Value {
	readonly _milliseconds: number;
	constructor(input: Duration | number | string);
	static fromCompact([s, ns]: [
		number,
		number
	] | [
		number
	] | [
	]): Duration;
	equals(other: unknown): boolean;
	toCompact(): [
		number,
		number
	] | [
		number
	] | [
	];
	toString(): string;
	toJSON(): string;
	static parseString(input: string): number;
	static nanoseconds(nanoseconds: number): Duration;
	static microseconds(microseconds: number): Duration;
	static milliseconds(milliseconds: number): Duration;
	static seconds(seconds: number): Duration;
	static minutes(minutes: number): Duration;
	static hours(hours: number): Duration;
	static days(days: number): Duration;
	static weeks(weeks: number): Duration;
	get microseconds(): number;
	get nanoseconds(): number;
	get milliseconds(): number;
	get seconds(): number;
	get minutes(): number;
	get hours(): number;
	get days(): number;
	get weeks(): number;
}
/**
 * A SurrealQL decimal value.
 */
export declare class Decimal extends Value {
	readonly decimal: string;
	constructor(decimal: string | number | Decimal);
	equals(other: unknown): boolean;
	toString(): string;
	toJSON(): string;
}
/**
 * A SurrealQL table value.
 */
export declare class Table<Tb extends string = string> extends Value {
	readonly tb: Tb;
	constructor(tb: Tb);
	equals(other: unknown): boolean;
	toJSON(): string;
	toString(): string;
}
/**
 * A SurrealQL geometry value.
 */
export declare abstract class Geometry extends Value {
	abstract toJSON(): GeoJson;
	abstract is(geometry: Geometry): boolean;
	abstract clone(): Geometry;
	equals(other: unknown): boolean;
	toString(): string;
}
/**
 * A SurrealQL point geometry value.
 */
export declare class GeometryPoint extends Geometry {
	readonly point: [
		number,
		number
	];
	constructor(point: [
		number | Decimal,
		number | Decimal
	] | GeometryPoint);
	toJSON(): GeoJsonPoint;
	get coordinates(): GeoJsonPoint["coordinates"];
	is(geometry: Geometry): geometry is GeometryPoint;
	clone(): GeometryPoint;
}
/**
 * A SurrealQL line geometry value.
 */
export declare class GeometryLine extends Geometry {
	readonly line: [
		GeometryPoint,
		GeometryPoint,
		...GeometryPoint[]
	];
	constructor(line: [
		GeometryPoint,
		GeometryPoint,
		...GeometryPoint[]
	] | GeometryLine);
	toJSON(): GeoJsonLineString;
	get coordinates(): GeoJsonLineString["coordinates"];
	close(): void;
	is(geometry: Geometry): geometry is GeometryLine;
	clone(): GeometryLine;
}
/**
 * A SurrealQL polygon geometry value.
 */
export declare class GeometryPolygon extends Geometry {
	readonly polygon: [
		GeometryLine,
		...GeometryLine[]
	];
	constructor(polygon: [
		GeometryLine,
		...GeometryLine[]
	] | GeometryPolygon);
	toJSON(): GeoJsonPolygon;
	get coordinates(): GeoJsonPolygon["coordinates"];
	is(geometry: Geometry): geometry is GeometryPolygon;
	clone(): GeometryPolygon;
}
/**
 * A SurrealQL multi-point geometry value.
 */
export declare class GeometryMultiPoint extends Geometry {
	readonly points: [
		GeometryPoint,
		...GeometryPoint[]
	];
	constructor(points: [
		GeometryPoint,
		...GeometryPoint[]
	] | GeometryMultiPoint);
	toJSON(): GeoJsonMultiPoint;
	get coordinates(): GeoJsonMultiPoint["coordinates"];
	is(geometry: Geometry): geometry is GeometryMultiPoint;
	clone(): GeometryMultiPoint;
}
/**
 * A SurrealQL multi-line geometry value.
 */
export declare class GeometryMultiLine extends Geometry {
	readonly lines: [
		GeometryLine,
		...GeometryLine[]
	];
	constructor(lines: [
		GeometryLine,
		...GeometryLine[]
	] | GeometryMultiLine);
	toJSON(): GeoJsonMultiLineString;
	get coordinates(): GeoJsonMultiLineString["coordinates"];
	is(geometry: Geometry): geometry is GeometryMultiLine;
	clone(): GeometryMultiLine;
}
/**
 * A SurrealQL multi-polygon geometry value.
 */
export declare class GeometryMultiPolygon extends Geometry {
	readonly polygons: [
		GeometryPolygon,
		...GeometryPolygon[]
	];
	constructor(polygons: [
		GeometryPolygon,
		...GeometryPolygon[]
	] | GeometryMultiPolygon);
	toJSON(): GeoJsonMultiPolygon;
	get coordinates(): GeoJsonMultiPolygon["coordinates"];
	is(geometry: Geometry): geometry is GeometryMultiPolygon;
	clone(): GeometryMultiPolygon;
}
/**
 * A SurrealQL geometry collection value.
 */
export declare class GeometryCollection extends Geometry {
	readonly collection: [
		Geometry,
		...Geometry[]
	];
	constructor(collection: [
		Geometry,
		...Geometry[]
	] | GeometryCollection);
	toJSON(): GeoJsonCollection;
	get geometries(): GeoJsonCollection["geometries"];
	is(geometry: Geometry): geometry is GeometryCollection;
	clone(): GeometryCollection;
}
type GeoJson = GeoJsonPoint | GeoJsonLineString | GeoJsonPolygon | GeoJsonMultiPoint | GeoJsonMultiLineString | GeoJsonMultiPolygon | GeoJsonCollection;
type GeoJsonPoint = {
	type: "Point";
	coordinates: [
		number,
		number
	];
};
type GeoJsonLineString = {
	type: "LineString";
	coordinates: [
		GeoJsonPoint["coordinates"],
		GeoJsonPoint["coordinates"],
		...GeoJsonPoint["coordinates"][]
	];
};
type GeoJsonPolygon = {
	type: "Polygon";
	coordinates: [
		GeoJsonLineString["coordinates"],
		...GeoJsonLineString["coordinates"][]
	];
};
type GeoJsonMultiPoint = {
	type: "MultiPoint";
	coordinates: [
		GeoJsonPoint["coordinates"],
		...GeoJsonPoint["coordinates"][]
	];
};
type GeoJsonMultiLineString = {
	type: "MultiLineString";
	coordinates: [
		GeoJsonLineString["coordinates"],
		...GeoJsonLineString["coordinates"][]
	];
};
type GeoJsonMultiPolygon = {
	type: "MultiPolygon";
	coordinates: [
		GeoJsonPolygon["coordinates"],
		...GeoJsonPolygon["coordinates"][]
	];
};
type GeoJsonCollection = {
	type: "GeometryCollection";
	geometries: GeoJson[];
};
/**
 * Recursively encode any supported SurrealQL value into a binary CBOR representation.
 * @param data - The input value
 * @returns CBOR binary representation
 */
export declare function encodeCbor<T>(data: T): ArrayBuffer;
/**
 * Decode a CBOR encoded SurrealQL value into object representation.
 * @param data - The encoded SurrealQL value
 * @returns The parsed SurrealQL value
 */
export declare function decodeCbor(data: ArrayBufferLike): any;
type R = Prettify<Record<string, unknown>>;
type RecordId$1<Tb extends string = string> = RecordId<Tb> | StringRecordId;
export declare class Surreal extends AuthController {
	connection: AbstractEngine | undefined;
	emitter: Emitter<EngineEvents>;
	protected engines: Engines;
	private _ready?;
	constructor({ engines, }?: {
		engines?: Engines;
	});
	/**
	 * Establish a socket connection to the database
	 * @param connection - Connection details
	 */
	connect(url: string | URL, opts?: ConnectOptions): Promise<true>;
	private connectInner;
	/**
	 * Disconnect the socket to the database
	 */
	close(): Promise<true>;
	private clean;
	/**
	 * Check if connection is ready
	 */
	get status(): ConnectionStatus;
	/**
	 * A promise which resolves when the connection is ready
	 */
	get ready(): Promise<void>;
	/**
	 * Ping SurrealDB instance
	 */
	ping(): Promise<true>;
	/**
	 * Switch to a specific namespace and database.
	 * @param database - Switches to a specific namespace.
	 * @param db - Switches to a specific database.
	 */
	use({ namespace, database, }: {
		namespace?: string | null;
		database?: string | null;
	}): Promise<true>;
	/**
	 * Selects everything from the [$auth](https://surrealdb.com/docs/surrealql/parameters) variable.
	 * ```sql
	 * SELECT * FROM $auth;
	 * ```
	 * Make sure the user actually has the permission to select their own record, otherwise you'll get back an empty result.
	 * @return The record linked to the record ID used for authentication
	 */
	info<T extends R>(): Promise<ActionResult<T> | undefined>;
	/**
	 * Specify a variable for the current socket connection.
	 * @param key - Specifies the name of the variable.
	 * @param val - Assigns the value to the variable name.
	 */
	let(variable: string, value: unknown): Promise<true>;
	/**
	 * Remove a variable from the current socket connection.
	 * @param key - Specifies the name of the variable.
	 */
	unset(variable: string): Promise<true>;
	/**
	 * Start a live select query and invoke the callback with responses
	 * @param table - The table that you want to receive live results for.
	 * @param callback - Callback function that receives updates.
	 * @param diff - If set to true, will return a set of patches instead of complete records
	 * @returns A unique subscription ID
	 */
	live<Result extends Record<string, unknown> | Patch = Record<string, unknown>>(table: RecordIdRange | Table | string, callback?: LiveHandler<Result>, diff?: boolean): Promise<Uuid>;
	/**
	 * Subscribe to an existing live select query and invoke the callback with responses
	 * @param queryUuid - The unique ID of an existing live query you want to receive updates for.
	 * @param callback - Callback function that receives updates.
	 */
	subscribeLive<Result extends Record<string, unknown> | Patch = Record<string, unknown>>(queryUuid: Uuid, callback: LiveHandler<Result>): Promise<void>;
	/**
	 * Unsubscribe a callback from a live select query
	 * @param queryUuid - The unique ID of an existing live query you want to ubsubscribe from.
	 * @param callback - The previously subscribed callback function.
	 */
	unSubscribeLive<Result extends Record<string, unknown> | Patch = Record<string, unknown>>(queryUuid: Uuid, callback: LiveHandler<Result>): Promise<void>;
	/**
	 * Kill a live query
	 * @param queryUuid - The query that you want to kill.
	 */
	kill(queryUuid: Uuid | readonly Uuid[]): Promise<void>;
	/**
	 * Runs a set of SurrealQL statements against the database.
	 * @param query - Specifies the SurrealQL statements.
	 * @param bindings - Assigns variables which can be used in the query.
	 */
	query<T extends unknown[]>(...args: QueryParameters): Promise<Prettify<T>>;
	/**
	 * Runs a set of SurrealQL statements against the database.
	 * @param query - Specifies the SurrealQL statements.
	 * @param bindings - Assigns variables which can be used in the query.
	 */
	queryRaw<T extends unknown[]>(...[q, b]: QueryParameters): Promise<Prettify<MapQueryResult<T>>>;
	/**
	 * Runs a set of SurrealQL statements against the database.
	 * @param query - Specifies the SurrealQL statements.
	 * @param bindings - Assigns variables which can be used in the query.
	 * @deprecated Use `queryRaw` instead
	 */
	query_raw<T extends unknown[]>(...args: QueryParameters): Promise<Prettify<MapQueryResult<T>>>;
	/**
	 * Selects all records in a table, or a specific record, from the database.
	 * If you intend on sorting, filtering, or performing other operations on the data, it is recommended to use the `query` method instead.
	 * @param thing - The table name or a record ID to select.
	 */
	select<T extends R>(thing: RecordId$1): Promise<ActionResult<T>>;
	select<T extends R>(thing: RecordIdRange | Table | string): Promise<ActionResult<T>[]>;
	/**
	 * Creates a record in the database.
	 * @param thing - The table name or the specific record ID to create.
	 * @param data - The document / record data to insert.
	 */
	create<T extends R, U extends R = T>(thing: RecordId$1, data?: U): Promise<ActionResult<T>>;
	create<T extends R, U extends R = T>(thing: Table | string, data?: U): Promise<ActionResult<T>[]>;
	/**
	 * Inserts one or multiple records in the database.
	 * @param table - The table name to insert into.
	 * @param data - The document(s) / record(s) to insert.
	 */
	insert<T extends R, U extends R = T>(data?: U | U[]): Promise<ActionResult<T>[]>;
	insert<T extends R, U extends R = T>(table: Table | string, data?: U | U[]): Promise<ActionResult<T>[]>;
	/**
	 * Inserts one or multiple records in the database.
	 * @param thing - The table name or the specific record ID to create.
	 * @param data - The document(s) / record(s) to insert.
	 */
	insertRelation<T extends R, U extends R = T>(data?: U | U[]): Promise<ActionResult<T>[]>;
	insertRelation<T extends R, U extends R = T>(table: Table | string, data?: U | U[]): Promise<ActionResult<T>[]>;
	/**
	 * Inserts one or multiple records in the database.
	 * @param thing - The table name or the specific record ID to create.
	 * @param data - The document(s) / record(s) to insert.
	 * @deprecated Use `insertRelation` instead
	 */
	insert_relation<T extends R, U extends R = T>(data?: U | U[]): Promise<ActionResult<T>[]>;
	insert_relation<T extends R, U extends R = T>(table: Table | string, data?: U | U[]): Promise<ActionResult<T>[]>;
	/**
	 * Updates all records in a table, or a specific record, in the database.
	 *
	 * ***NOTE: This function replaces the current document / record data with the specified data.***
	 * @param thing - The table name or the specific record ID to update.
	 * @param data - The document / record data to insert.
	 */
	update<T extends R, U extends R = T>(thing: RecordId$1, data?: U): Promise<ActionResult<T>>;
	update<T extends R, U extends R = T>(thing: RecordIdRange | Table | string, data?: U): Promise<ActionResult<T>[]>;
	/**
	 * Upserts all records in a table, or a specific record, in the database.
	 *
	 * ***NOTE: This function replaces the current document / record data with the specified data.***
	 * @param thing - The table name or the specific record ID to upsert.
	 * @param data - The document / record data to insert.
	 */
	upsert<T extends R, U extends R = T>(thing: RecordId$1, data?: U): Promise<ActionResult<T>>;
	upsert<T extends R, U extends R = T>(thing: RecordIdRange | Table | string, data?: U): Promise<ActionResult<T>[]>;
	/**
	 * Modifies all records in a table, or a specific record, in the database.
	 *
	 * ***NOTE: This function merges the current document / record data with the specified data.***
	 * @param thing - The table name or the specific record ID to change.
	 * @param data - The document / record data to insert.
	 */
	merge<T extends R, U extends R = Partial<T>>(thing: RecordId$1, data?: U): Promise<ActionResult<T>>;
	merge<T extends R, U extends R = Partial<T>>(thing: RecordIdRange | Table | string, data?: U): Promise<ActionResult<T>[]>;
	/**
	 * Applies JSON Patch changes to all records, or a specific record, in the database.
	 *
	 * ***NOTE: This function patches the current document / record data with the specified JSON Patch data.***
	 * @param thing - The table name or the specific record ID to modify.
	 * @param data - The JSON Patch data with which to modify the records.
	 */
	patch<T extends R>(thing: RecordId$1, data?: Patch[], diff?: false): Promise<ActionResult<T>>;
	patch<T extends R>(thing: RecordIdRange | Table | string, data?: Patch[], diff?: false): Promise<ActionResult<T>[]>;
	patch<T extends R>(thing: RecordId$1, data: undefined | Patch[], diff: true): Promise<Patch[]>;
	patch<T extends R>(thing: RecordIdRange | Table | string, data: undefined | Patch[], diff: true): Promise<Patch[][]>;
	/**
	 * Deletes all records in a table, or a specific record, from the database.
	 * @param thing - The table name or a record ID to select.
	 */
	delete<T extends R>(thing: RecordId$1): Promise<ActionResult<T>>;
	delete<T extends R>(thing: RecordIdRange | Table | string): Promise<ActionResult<T>[]>;
	/**
	 * Obtain the version of the SurrealDB instance
	 * @example `surrealdb-2.1.0`
	 */
	version(): Promise<string>;
	/**
	 * Run a SurrealQL function
	 * @param name - The full name of the function
	 * @param args - The arguments supplied to the function. You can also supply a version here as a string, in which case the third argument becomes the parameter list.
	 */
	run<T>(name: string, args?: unknown[]): Promise<T>;
	/**
	 * Run a SurrealQL function
	 * @param name - The full name of the function
	 * @param version - The version of the function. If omitted, the second argument is the parameter list.
	 * @param args - The arguments supplied to the function.
	 */
	run<T>(name: string, version: string, args?: unknown[]): Promise<T>;
	/**
	 * Obtain the version of the SurrealDB instance
	 * @param from - The in property on the edge record
	 * @param thing - The id of the edge record
	 * @param to - The out property on the edge record
	 * @param data - Optionally, provide a body for the edge record
	 */
	relate<T extends R, U extends R = T>(from: string | RecordId$1 | RecordId$1[], thing: RecordId$1, to: string | RecordId$1 | RecordId$1[], data?: U): Promise<T>;
	relate<T extends R, U extends R = T>(from: string | RecordId$1 | RecordId$1[], thing: string, to: string | RecordId$1 | RecordId$1[], data?: U): Promise<T[]>;
	/**
	 * Send a raw message to the SurrealDB instance
	 * @param method - Type of message to send.
	 * @param params - Parameters for the message.
	 */
	rpc<Result>(method: string, params?: unknown[]): Promise<RpcResponse<Result>>;
	/**
	 * Export the database and return the result as a string
	 * @param options - Export configuration options
	 */
	export(options?: Partial<ExportOptions>): Promise<string>;
	/**
	 * Import an existing export into the database
	 * @param input - The data to import
	 */
	import(input: string): Promise<void>;
}
declare class ReconnectContext {
	private _attempts;
	readonly options: ReconnectOptions;
	readonly surreal: Surreal;
	constructor(input: undefined | Partial<ReconnectOptions> | boolean, surreal: Surreal);
	get attempts(): number;
	get enabled(): boolean;
	get allowed(): boolean;
	reset(): void;
	iterate(): Promise<void>;
}
export type Engine = new (context: EngineContext) => AbstractEngine;
export type Engines = Record<string, Engine>;
declare const RetryMessage: unique symbol;
export type EngineEvents = {
	connecting: [
	];
	connected: [
	];
	reconnecting: [
	];
	disconnected: [
	];
	error: [
		Error
	];
	[K: `rpc-${string | number}`]: [
		RpcResponse | EngineDisconnected | typeof RetryMessage
	];
	[K: `live-${string}`]: LiveHandlerArguments;
};
export declare enum ConnectionStatus {
	Disconnected = "disconnected",
	Connecting = "connecting",
	Reconnecting = "reconnecting",
	Connected = "connected",
	Error = "error"
}
declare class EngineContext {
	readonly emitter: Emitter<EngineEvents>;
	readonly encodeCbor: (value: unknown) => ArrayBuffer;
	readonly decodeCbor: (value: ArrayBufferLike) => any;
	readonly reconnect: ReconnectContext;
	readonly prepare: PrepareFn | undefined;
	constructor({ emitter, encodeCbor, decodeCbor, reconnect, prepare, }: {
		emitter: Emitter<EngineEvents>;
		encodeCbor: (value: unknown) => ArrayBuffer;
		decodeCbor: (value: ArrayBufferLike) => any;
		reconnect: ReconnectContext;
		prepare: PrepareFn | undefined;
	});
}
export declare abstract class AbstractEngine {
	readonly context: EngineContext;
	ready: Promise<void> | undefined;
	status: ConnectionStatus;
	connection: {
		url: URL | undefined;
		namespace: string | undefined;
		database: string | undefined;
		token: string | undefined;
	};
	constructor(context: EngineContext);
	get emitter(): EngineContext["emitter"];
	get encodeCbor(): EngineContext["encodeCbor"];
	get decodeCbor(): EngineContext["decodeCbor"];
	abstract connect(url: URL): Promise<void>;
	abstract disconnect(): Promise<void>;
	abstract rpc<Method extends string, Params extends unknown[] | undefined, Result>(request: RpcRequest<Method, Params>, force?: boolean): Promise<RpcResponse<Result>>;
	abstract version(url: URL, timeout?: number): Promise<string>;
	abstract export(options?: Partial<ExportOptions>): Promise<string>;
	abstract import(data: string): Promise<void>;
}
export declare abstract class AuthController {
	abstract connection: AbstractEngine | undefined;
	abstract rpc<Result>(method: string, params?: unknown[]): Promise<RpcResponse<Result>>;
	/**
	 * Signs up to a specific authentication scope.
	 * @param vars - Variables used in a signup query.
	 * @return The authentication token.
	 */
	signup(vars: ScopeAuth | AccessRecordAuth): Promise<Token>;
	/**
	 * Signs in to a specific authentication scope.
	 * @param vars - Variables used in a signin query.
	 * @return The authentication token.
	 */
	signin(vars: AnyAuth): Promise<Token>;
	/**
	 * Authenticates the current connection with a JWT token.
	 * @param token - The JWT authentication token.
	 */
	authenticate(token: Token): Promise<true>;
	/**
	 * Invalidates the authentication for the current connection.
	 */
	invalidate(): Promise<true>;
}
export declare class EngineAuth extends AuthController {
	connection: AbstractEngine;
	constructor(connection: AbstractEngine);
	rpc<Result>(method: string, params?: unknown[]): Promise<RpcResponse<Result>>;
}
export type ActionResult<T extends Record<string, unknown>> = Prettify<T["id"] extends RecordId ? T : {
	id: RecordId;
} & T>;
export type Prettify<T> = {
	[K in keyof T]: T[K];
} & {};
export type QueryParameters = [
	query: string,
	bindings?: Record<string, unknown>
] | [
	prepared: PreparedQuery,
	gaps?: Fill[]
];
export declare function convertAuth(params: AnyAuth): Record<string, unknown>;
export type RootAuth = {
	username: string;
	password: string;
};
export type NamespaceAuth = {
	namespace: string;
	username: string;
	password: string;
};
export type DatabaseAuth = {
	namespace: string;
	database: string;
	username: string;
	password: string;
};
export type AccessSystemAuth = Prettify<(RootAuth | NamespaceAuth | DatabaseAuth) & {
	access: string;
	variables?: never;
}>;
export type ScopeAuth = {
	namespace?: string;
	database?: string;
	scope: string;
	[K: string]: unknown;
};
export type AccessRecordAuth = {
	namespace?: string;
	database?: string;
	access: string;
	variables: {
		ns?: never;
		db?: never;
		ac?: never;
		[K: string]: unknown;
	};
};
export type AnyAuth = RootAuth | NamespaceAuth | DatabaseAuth | ScopeAuth | AccessSystemAuth | AccessRecordAuth;
export type Token = string;
export type AuthClient = Pick<Surreal, "signin" | "signup" | "authenticate" | "invalidate">;
export type QueryResult<T = unknown> = QueryResultOk<T> | QueryResultErr;
export type QueryResultOk<T> = {
	status: "OK";
	time: string;
	result: T;
};
export type QueryResultErr = {
	status: "ERR";
	time: string;
	result: string;
};
export type MapQueryResult<T> = {
	[K in keyof T]: QueryResult<T[K]>;
};
type BasePatch<T = string> = {
	path: T;
};
export type AddPatch<T = string, U = unknown> = BasePatch<T> & {
	op: "add";
	value: U;
};
export type RemovePatch<T = string> = BasePatch<T> & {
	op: "remove";
};
export type ReplacePatch<T = string, U = unknown> = BasePatch<T> & {
	op: "replace";
	value: U;
};
export type ChangePatch<T = string, U = string> = BasePatch<T> & {
	op: "change";
	value: U;
};
export type CopyPatch<T = string, U = string> = BasePatch<T> & {
	op: "copy";
	from: U;
};
export type MovePatch<T = string, U = string> = BasePatch<T> & {
	op: "move";
	from: U;
};
export type TestPatch<T = string, U = unknown> = BasePatch<T> & {
	op: "test";
	value: U;
};
export type Patch = AddPatch | RemovePatch | ReplacePatch | ChangePatch | CopyPatch | MovePatch | TestPatch;
export type RpcRequest<Method extends string = string, Params extends unknown[] | undefined = unknown[]> = {
	method: Method;
	params?: Params;
};
export type RpcResponse<Result = unknown> = RpcResponseOk<Result> | RpcResponseErr;
export type RpcResponseOk<Result = unknown> = {
	result: Result;
	error?: never;
};
export type RpcResponseErr = {
	result?: never;
	error: {
		code: number;
		message: string;
	};
};
export declare const liveActions: readonly [
	"CREATE",
	"UPDATE",
	"DELETE"
];
export type LiveAction = (typeof liveActions)[number];
export type LiveResult = {
	id: Uuid;
	action: LiveAction;
	result: Record<string, unknown>;
};
export type LiveHandlerArguments<Result extends Record<string, unknown> | Patch = Record<string, unknown>> = [
	action: LiveAction,
	result: Result
] | [
	action: "CLOSE",
	result: "killed" | "disconnected"
];
export type LiveHandler<Result extends Record<string, unknown> | Patch = Record<string, unknown>> = (...[action, result]: LiveHandlerArguments<Result>) => unknown;
export declare function isLiveResult(v: unknown): v is LiveResult;
export type ExportOptions = {
	users: boolean;
	accesses: boolean;
	params: boolean;
	functions: boolean;
	analyzers: boolean;
	versions: boolean;
	tables: boolean | string[];
	records: boolean;
};
export declare const DEFAULT_RECONNECT_OPTIONS: ReconnectOptions;
export type PrepareFn = (auth: AuthController) => unknown;
export interface ConnectOptions {
	/** The namespace to connect to */
	namespace?: string;
	/** The database to connect to */
	database?: string;
	/** Authentication details to use */
	auth?: AnyAuth | Token;
	/** A callback to customise the connection before connection completion */
	prepare?: PrepareFn;
	/** Enable automated SurrealDB version checking */
	versionCheck?: boolean;
	/** The maximum amount of time in milliseconds to wait for version checking */
	versionCheckTimeout?: number;
	/** Configure reconnect behavior */
	reconnect?: boolean | Partial<ReconnectOptions>;
}
export interface ReconnectOptions {
	/** Reconnect after a connection has unexpectedly dropped */
	enabled: boolean;
	/** How many attempts will be made at reconnecting, -1 for unlimited */
	attempts: number;
	/** The minimum amount of time in milliseconds to wait before reconnecting */
	retryDelay: number;
	/** The maximum amount of time in milliseconds to wait before reconnecting */
	retryDelayMax: number;
	/** The amount to multiply the delay by after each failed attempt */
	retryDelayMultiplier: number;
	/** A float percentage to randomly offset each delay by  */
	retryDelayJitter: number;
}
/**
 * Recursively compare supported SurrealQL values for equality.
 *
 * @param x The first value to compare
 * @param y The second value to compare
 * @returns Whether the two values are recursively equal
 */
export declare function equals(x: unknown, y: unknown): boolean;
export type Jsonify<T> = T extends Date | Uuid | Decimal | Duration | Future | Range$1<unknown, unknown> | StringRecordId ? string : T extends undefined ? never : T extends Record<string | number | symbol, unknown> | Array<unknown> ? {
	[K in keyof T]: Jsonify<T[K]>;
} : T extends Map<infer K, infer V> ? Map<K, Jsonify<V>> : T extends Set<infer V> ? Set<Jsonify<V>> : T extends Geometry ? ReturnType<T["toJSON"]> : T extends RecordId<infer Tb> ? `${Tb}:${string}` : T extends RecordIdRange<infer Tb> ? `${Tb}:${string}..${string}` : T extends Table<infer Tb> ? `${Tb}` : T;
/**
 * Recursively convert any supported SurrealQL value into a serializable JSON representation.
 * @param input - The input value
 * @returns JSON-safe representation
 */
export declare function jsonify<T>(input: T): Jsonify<T>;
type Version = `${number}.${number}.${number}`;
export declare const defaultVersionCheckTimeout = 5000;
export declare const supportedSurrealDbVersionMin: Version;
export declare const supportedSurrealDbVersionUntil: Version;
export declare const supportedSurrealDbVersionRange: string;
export declare function versionCheck(version: string, min?: Version, until?: Version): true;
export declare function isVersionSupported(version: string, min?: Version, until?: Version): boolean;
/**
 * Query the version of a remote SurrealDB instance
 * @param url - The URL of the remote SurrealDB instance
 * @param timeout - The timeout in milliseconds for the request
 * @returns
 */
export declare function retrieveRemoteVersion(url: URL, timeout?: number): Promise<Version>;
export declare function getIncrementalID(): string;
/**
 * A template literal tag function for parsing a string type
 * @param string - The string to parse
 * @param values - The interpolated values
 * @returns The parsed string
 */
export declare function s(string: string[] | TemplateStringsArray, ...values: unknown[]): string;
/**
 * A template literal tag function for parsing a string into a Date
 * @param string - The string to parse
 * @param values - The interpolated values
 * @returns The parsed Date
 */
export declare function d(string: string[] | TemplateStringsArray, ...values: unknown[]): Date;
/**
 * A template literal tag function for parsing a string into a StringRecordId
 * @param string - The string to parse
 * @param values - The interpolated values
 * @returns The parsed StringRecordId
 */
export declare function r(string: string[] | TemplateStringsArray, ...values: unknown[]): StringRecordId;
/**
 * A template literal tag function for parsing a string into a Uuid
 * @param string - The string to parse
 * @param values - The interpolated values
 * @returns The parsed Uuid
 */
export declare function u(string: string[] | TemplateStringsArray, ...values: unknown[]): Uuid;
/**
 * Recursively print any supported SurrealQL value into a string representation.
 * @param input - The input value
 * @returns Stringified SurrealQL representation
 */
export declare function toSurrealqlString(input: unknown): string;
/**
 * Escape a given string to be used as a valid SurrealQL ident.
 * @param str - The string to escape
 * @returns Optionally escaped string
 */
export declare function escapeIdent(str: string): string;
/**
 * Escape a given string to be used as a valid SurrealQL ident.
 * @param str - The string to escape
 * @returns Optionally escaped string
 * @deprecated Use `escapeIdent` instead
 */
export declare function escape_ident(str: string): string;
/**
 * Escape a number to be used as a valid SurrealQL ident.
 * @param num - The number to escape
 * @returns Optionally escaped number
 */
export declare function escapeNumber(num: number | bigint): string;

declare namespace cbor {
	export { CborBreak, CborError, CborFillMissing, CborInvalidMajorError, CborNumberError, CborPartialDisabled, CborRangeError, DecodeOptions, Encoded, EncoderOptions, Fill, Gap, Major, POW_2_53, POW_2_64, PartiallyEncoded, Reader, Replacer, Tagged, Writer, decode, encode, infiniteBytes, partiallyEncodeObject };
}

export {
	Range$1 as Range,
	Surreal as default,
	cbor,
	surrealql as surql,
};

export {};
